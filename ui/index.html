<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Radio</title>
<style>
  :root {
    --bg: #0f1115; --card:#171a22; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4da3ff;
    --ok:#3ddc97; --warn:#ffb020; --err:#ff5d5d; --radius:14px;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.4 system-ui, sans-serif; display:flex; height:100vh; }
  a { color:var(--accent); text-decoration:none; }

  /* Sidebar */
  .sidebar { width:260px; background:#13161d; border-right:1px solid #1f2531; display:flex; flex-direction:column; padding:16px; gap:12px; }
  .sidebar h1 { font-size:20px; margin:0 0 6px; }
  .btn { appearance:none; border:1px solid #2a2f3a; background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; text-align:left; }
  .btn:hover { border-color:#3a4150; }
  .btn.accent { background:var(--accent); border-color:var(--accent); color:#041427; }
  .btn.warn { background:var(--warn); border-color:var(--warn); color:#271400; }
  audio { width:100%; }

  /* Main */
  .main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
  header { padding:16px; border-bottom:1px solid #1f2531; display:flex; justify-content:space-between; align-items:center; }
  header .title { font-size:18px; font-weight:600; }
  .timeline { flex:1; overflow-y:auto; padding:16px; display:flex; flex-direction:column; gap:16px; }
  
  /* Timeline sections */
  .timeline-section { background:var(--card); border-radius:var(--radius); border:1px solid #202634; overflow:hidden; }
  .section-header { padding:12px 16px; border-bottom:1px solid #202634; font-weight:600; font-size:14px; text-transform:uppercase; letter-spacing:0.5px; }
  .section-header.live { background:linear-gradient(135deg, #ff4d4d, #ff6b6b); color:white; }
  .section-header.upcoming { background:linear-gradient(135deg, #4da3ff, #6bb6ff); color:white; }
  .section-header.recent { background:linear-gradient(135deg, #3ddc97, #5ce1a6); color:white; }

  .event { padding:12px 16px; border-bottom:1px solid #202634; display:flex; gap:12px; }
  .event:last-child { border-bottom:none; }
  .event.highlighted { background:rgba(77, 163, 255, 0.1); }
  .event img { width:60px; height:60px; border-radius:8px; object-fit:cover; background:#0b0d12; border:1px solid #1f2531; flex-shrink:0; }
  .event-details { flex:1; min-width:0; }
  .event-meta { font-size:12px; color:var(--muted); margin-bottom:4px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .event-title { font-weight:600; margin-bottom:2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .event-sub { font-size:14px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  
  .chip { padding:2px 8px; border-radius:12px; font-size:11px; font-weight:500; }
  .chip.live { background:#ff4d4d; color:white; animation:pulse 2s infinite; }
  .chip.time-left { background:#4da3ff; color:white; }
  .chip.dj { background:#9b59b6; color:white; }
  .chip.upcoming { background:#6c757d; color:white; }

  @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.7; } }

  .empty-state { padding:20px; text-align:center; color:var(--muted); font-style:italic; }

  /* Mobile styles */
  @media (max-width: 768px) {
    body { flex-direction:column; }
    .sidebar {
      flex-direction:row; flex-wrap:wrap; width:100%; border-right:none;
      border-bottom:1px solid #1f2531; align-items:center; gap:8px;
    }
    .sidebar h1 { flex:1 1 100%; margin-bottom:4px; }
    .btn { flex:1; font-size:14px; padding:8px; text-align:center; }
    audio { position:sticky; top:0; z-index:10; background:#13161d; }
    .timeline { padding:8px; gap:12px; }
    .event { padding:8px 12px; }
    .event img { width:50px; height:50px; }
  }
</style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>üéß AI Radio</h1>
    <a class="btn" id="openLink" href="#" target="_blank" rel="noopener">üîó Open Stream</a>
    <a class="btn" href="http://icecast.zorro.local:8000" target="_blank">üìä Icecast Admin</a>
    <audio id="livePlayer" controls preload="none"></audio>
    <button class="btn warn" id="skipBtn">‚è≠Ô∏è Skip Track</button>
    <button class="btn accent" id="genBtn">‚ú® Generate DJ Line</button>
  </aside>

  <!-- Main content -->
  <div class="main">
    <header>
      <div class="title">üìú Live Timeline</div>
      <div id="statusIndicator" style="font-size:12px; color:var(--muted);"></div>
    </header>
    <div id="timeline" class="timeline"></div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = (id) => document.getElementById(id);
  const STREAM_URL = "http://icecast.zorro.local:8000/stream.mp3";
  $('livePlayer').src = STREAM_URL;
  $('livePlayer').load();
  $('openLink').href = STREAM_URL;

  // Fetch helper
  async function j(url, opts = {}) {
    const r = await fetch(url, { headers: { 'Content-Type': 'application/json' }, ...opts });
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  }

  const fmtTime = (ts) => ts ? new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

  // Track comparison functions
  function tracksEqual(a, b) {
    if (!a || !b) return false;
    
    // Exact filename match is most reliable
    if (a.filename && b.filename && a.filename === b.filename) {
      return true;
    }
    
    // Title/artist match with some fuzzy logic
    const titleA = (a.title || '').toLowerCase().trim();
    const titleB = (b.title || '').toLowerCase().trim();
    const artistA = (a.artist || '').toLowerCase().trim();
    const artistB = (b.artist || '').toLowerCase().trim();
    
    if (titleA && titleB && titleA.length > 2 && titleB.length > 2) {
      return titleA === titleB && artistA === artistB;
    }
    
    return false;
  }

  function getTrackKey(track) {
    if (track.filename) return `file:${track.filename}`;
    const title = (track.title || '').toLowerCase().trim();
    const artist = (track.artist || '').toLowerCase().trim();
    return `track:${title}|${artist}`;
  }

  // Cover art helpers
  function getCoverUrl(track) {
    if (track.artwork_url && !track.artwork_url.endsWith('/station-cover.jpg')) {
      return track.artwork_url;
    }
    if (track.filename) {
      return `/api/cover?file=${encodeURIComponent(track.filename)}`;
    }
    return '/static/station-cover.jpg';
  }

  function setCoverImage(imgEl, track) {
    if (!imgEl || !track) return;
    
    const url = getCoverUrl(track);
    imgEl.src = '/static/station-cover.jpg'; // Start with default
    
    if (url !== '/static/station-cover.jpg') {
      const testImg = new Image();
      testImg.onload = () => imgEl.src = url;
      testImg.onerror = () => {}; // Keep default on error
      testImg.src = url;
    }
  }

  // Timeline state
  let lastSignature = '';
  let updateTimer = null;

  async function loadTimeline() {
    try {
      const statusEl = $('statusIndicator');
      statusEl.textContent = 'Loading...';

      // Fetch all data
      const [nowData, nextData, historyData] = await Promise.all([
        j('/api/now').catch(() => null),
        j('/api/next').catch(() => []),
        j('/api/history').catch(() => [])
      ]);

      statusEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;

      // Process current track
      const currentTrack = nowData && (nowData.title || nowData.filename) ? {
        ...nowData,
        type: 'song',
        time: nowData.time || Date.now(),
        title: nowData.title || 'Unknown Track',
        artist: nowData.artist || 'Unknown Artist',
        album: nowData.album || ''
      } : null;

      // Process upcoming tracks - filter out current track
      const upcomingTracks = (nextData || [])
        .filter(track => !tracksEqual(track, currentTrack))
        .map((track, index) => ({
          type: 'upcoming',
          time: Date.now() + (index + 1) * 60000, // Estimated times
          title: track.title || 'Unknown Track',
          artist: track.artist || 'Unknown Artist', 
          album: track.album || '',
          filename: track.filename || '',
          artwork_url: track.artwork_url
        }));

      // Process history - filter out current and upcoming tracks
      const historyTracks = (historyData || [])
        .filter(event => {
          // Keep DJ events
          if (event.type === 'dj') return true;
          
          // Filter out current track
          if (currentTrack && tracksEqual(event, currentTrack)) return false;
          
          // Filter out upcoming tracks
          if (upcomingTracks.some(upcoming => tracksEqual(event, upcoming))) return false;
          
          return true;
        })
        .sort((a, b) => (b.time || 0) - (a.time || 0)); // Sort by time, newest first

      // Remove duplicate tracks from history (keep newest occurrence)
      const seenTracks = new Set();
      const deduplicatedHistory = historyTracks.filter(event => {
        if (event.type === 'dj') return true;
        
        const key = getTrackKey(event);
        if (seenTracks.has(key)) return false;
        seenTracks.add(key);
        return true;
      });

      // Create signature for change detection
      const signature = JSON.stringify({
        current: currentTrack ? `${currentTrack.title}|${currentTrack.artist}` : null,
        upcoming: upcomingTracks.slice(0, 5).map(t => `${t.title}|${t.artist}`),
        history: deduplicatedHistory.slice(0, 10).map(t => 
          t.type === 'dj' ? `dj:${t.text?.substring(0, 50)}` : `${t.title}|${t.artist}`
        )
      });

      // Skip render if nothing changed
      if (signature === lastSignature) {
        console.log('Timeline unchanged, skipping render');
        return;
      }
      lastSignature = signature;

      // Render timeline
      renderTimeline(currentTrack, upcomingTracks, deduplicatedHistory);

    } catch (error) {
      console.error('Timeline load error:', error);
      $('statusIndicator').textContent = 'Error loading';
      
      // Show error state
      const timeline = $('timeline');
      timeline.innerHTML = `
        <div class="timeline-section">
          <div class="section-header">‚ùå Error</div>
          <div class="empty-state">
            Unable to load timeline data. Retrying in 10 seconds...
          </div>
        </div>
      `;
    }
  }

  function renderTimeline(currentTrack, upcomingTracks, historyItems) {
    const timeline = $('timeline');
    timeline.innerHTML = '';

    // Helper to create elements
    function createElement(tag, className = '', innerHTML = '') {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      return el;
    }

    function createSection(title, className, items, renderer) {
      const section = createElement('div', 'timeline-section');
      const header = createElement('div', `section-header ${className}`, title);
      section.appendChild(header);

      if (items.length === 0) {
        const empty = createElement('div', 'empty-state', 
          className === 'upcoming' ? 'No upcoming tracks queued' :
          className === 'recent' ? 'No tracks played yet' :
          'No data available'
        );
        section.appendChild(empty);
      } else {
        items.forEach(item => {
          const eventEl = renderer(item);
          section.appendChild(eventEl);
        });
      }

      return section;
    }

    function formatRemaining(ms) {
      if (ms <= 0) return 'ending...';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')} left`;
    }

    // 1. LIVE NOW Section
    if (currentTrack) {
      const section = createSection('üî¥ LIVE NOW', 'live', [currentTrack], (track) => {
        const event = createElement('div', 'event highlighted');
        event.innerHTML = `
          <img alt="Album artwork">
          <div class="event-details">
            <div class="event-meta">
              <span>${fmtTime(track.time)}</span>
              <span class="chip live">LIVE</span>
              <span class="chip time-left" id="timeChip">--:--</span>
            </div>
            <div class="event-title">${track.title}</div>
            <div class="event-sub">${[track.artist, track.album].filter(Boolean).join(' ‚Ä¢ ')}</div>
          </div>
        `;

        const img = event.querySelector('img');
        setCoverImage(img, track);

        // Handle remaining time
        const timeChip = event.querySelector('#timeChip');
        if (track.duration_ms && track.elapsed_ms) {
          let remaining = track.duration_ms - track.elapsed_ms;
          timeChip.textContent = formatRemaining(remaining);
          
          const interval = setInterval(() => {
            remaining -= 1000;
            if (remaining <= 0) {
              timeChip.textContent = 'ending...';
              clearInterval(interval);
            } else {
              timeChip.textContent = formatRemaining(remaining);
            }
          }, 1000);
        } else {
          timeChip.textContent = 'playing';
        }

        return event;
      });
      timeline.appendChild(section);
    }

    // 2. UPCOMING Section
    const upcomingSection = createSection('‚è≠Ô∏è UPCOMING', 'upcoming', upcomingTracks.slice(0, 8), (track) => {
      const event = createElement('div', 'event');
      event.innerHTML = `
        <img alt="Album artwork">
        <div class="event-details">
          <div class="event-meta">
            <span class="chip upcoming">Up Next</span>
          </div>
          <div class="event-title">${track.title}</div>
          <div class="event-sub">${[track.artist, track.album].filter(Boolean).join(' ‚Ä¢ ')}</div>
        </div>
      `;

      const img = event.querySelector('img');
      setCoverImage(img, track);
      return event;
    });
    timeline.appendChild(upcomingSection);

    // 3. RECENTLY PLAYED Section
    const recentSection = createSection('üìÄ RECENTLY PLAYED', 'recent', historyItems.slice(0, 20), (item) => {
      const event = createElement('div', 'event');
      
      if (item.type === 'dj') {
        event.innerHTML = `
          <div class="event-details" style="width: 100%;">
            <div class="event-meta">
              <span>${fmtTime(item.time)}</span>
              <span class="chip dj">DJ</span>
            </div>
            <div class="event-title">üéôÔ∏è ${item.text || '(DJ announcement)'}</div>
            ${item.audio_url ? `<audio controls preload="none" src="${item.audio_url}" style="margin-top: 8px; width: 100%; max-width: 300px;"></audio>` : ''}
          </div>
        `;
      } else {
        event.innerHTML = `
          <img alt="Album artwork">
          <div class="event-details">
            <div class="event-meta">
              <span>${fmtTime(item.time)}</span>
            </div>
            <div class="event-title">${item.title}</div>
            <div class="event-sub">${[item.artist, item.album].filter(Boolean).join(' ‚Ä¢ ')}</div>
          </div>
        `;

        const img = event.querySelector('img');
        setCoverImage(img, item);
      }
      
      return event;
    });
    timeline.appendChild(recentSection);

    console.log('Timeline rendered successfully');
  }

  // Button handlers
  $('skipBtn').onclick = async () => {
    try {
      await j('/api/skip', { method: 'POST' });
      setTimeout(loadTimeline, 1000); // Reload after skip
    } catch (e) {
      console.error('Skip error:', e);
    }
  };

  $('genBtn').onclick = async () => {
    const btn = $('genBtn');
    const originalText = btn.textContent;
    
    try {
      btn.disabled = true;
      btn.textContent = 'Generating...';
      btn.style.backgroundColor = '#ffb020';

      const result = await j('/api/dj-now', { method: 'POST' });
      
      btn.textContent = result.ok ? 'Generated!' : 'Error!';
      btn.style.backgroundColor = result.ok ? '#3ddc97' : '#ff5d5d';
      
      if (result.ok) {
        setTimeout(loadTimeline, 1000); // Reload to show new DJ line
      }

    } catch (e) {
      console.error('DJ generation error:', e);
      btn.textContent = 'Error!';
      btn.style.backgroundColor = '#ff5d5d';
    } finally {
      setTimeout(() => {
        btn.disabled = false;
        btn.textContent = originalText;
        btn.style.backgroundColor = '';
      }, 3000);
    }
  };

  // Initialize
  loadTimeline();
  setInterval(loadTimeline, 10000); // Update every 10 seconds
});
</script>
</body>
</html>