<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Radio</title>
<style>
  :root {
    --bg: #0f1115; --card:#171a22; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4da3ff;
    --ok:#3ddc97; --warn:#ffb020; --err:#ff5d5d; --radius:14px;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.4 system-ui, sans-serif; display:flex; height:100vh; }
  a { color:var(--accent); text-decoration:none; }

  /* Sidebar */
  .sidebar { width:260px; background:#13161d; border-right:1px solid #1f2531; display:flex; flex-direction:column; padding:16px; gap:12px; }
  .sidebar h1 { font-size:20px; margin:0 0 6px; }
  .btn { appearance:none; border:1px solid #2a2f3a; background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; text-align:left; }
  .btn:hover { border-color:#3a4150; }
  .btn.accent { background:var(--accent); border-color:var(--accent); color:#041427; }
  .btn.warn { background:var(--warn); border-color:var(--warn); color:#271400; }
  audio { width:100%; }

  /* Main */
  .main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
  header { padding:16px; border-bottom:1px solid #1f2531; display:flex; justify-content:space-between; align-items:center; }
  header .title { font-size:18px; font-weight:600; }
  .timeline { flex:1; overflow-y:auto; padding:16px; display:flex; flex-direction:column; gap:12px; }
  .event { background:var(--card); border-radius:var(--radius); padding:12px; border:1px solid #202634; display:flex; gap:12px; }
  .event.dj { border-left:4px solid var(--accent); }
  .event.song { border-left:4px solid var(--ok); }
  .event.dj.generating { border-left-color: var(--warn); background: linear-gradient(90deg, var(--card), rgba(255, 176, 32, 0.05)); }
  .event.dj.completed { border-left-color: var(--ok); background: linear-gradient(90deg, var(--card), rgba(61, 220, 151, 0.05)); }
  .event.dj.failed { border-left-color: var(--err); background: linear-gradient(90deg, var(--card), rgba(255, 93, 93, 0.05)); }
  .event.upcoming { opacity:0.85; }
  .event img { width:60px; height:60px; border-radius:8px; object-fit:cover; background:#0b0d12; border:1px solid #1f2531; }
  .event-details { flex:1; }
  .event-meta { font-size:12px; color:var(--muted); margin-bottom:4px; display:flex; gap:8px; flex-wrap:wrap; }
  .voice-chip { padding:2px 6px; border-radius:999px; border:1px solid #1f2531; background:#0f1420; font-size:11px; color:var(--muted); }
  .event-title { font-weight:600; }
  .event-sub { font-size:14px; color:var(--muted); }
  .live-chip { display:inline-block; padding:2px 8px; border-radius:999px; background:#ff4d4d; color:white; font-size:11px; font-weight:bold; margin-right:6px; }

  /* Mobile */
  @media (max-width: 768px) {
    body { flex-direction:column; }
    .sidebar { flex-direction:row; flex-wrap:wrap; width:100%; border-right:none; border-bottom:1px solid #1f2531; align-items:center; gap:8px; }
    .sidebar h1 { flex:1 1 100%; margin-bottom:4px; }
    .btn { flex:1; font-size:14px; padding:8px; text-align:center; }
    audio { position:sticky; top:0; z-index:10; background:#13161d; }
    .timeline { padding:8px; }
  }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>üéß AI Radio</h1>
    <audio id="livePlayer" controls preload="none"></audio>
    <button class="btn warn" id="skipBtn">‚è≠Ô∏è Skip Track</button>
  </aside>

  <div class="main">
    <header><div class="title">üìú Live Timeline</div></header>
    <div id="timeline" class="timeline"></div>
  </div>

<script>
// --- constants & helpers
const STREAM_URL = "http://icecast.zorro.local:8000/stream.mp3";
const DEFAULT_ART = "/static/station-cover.jpg"; // server-served placeholder

const $ = (id) => document.getElementById(id);
$("livePlayer").src = STREAM_URL; $("livePlayer").load();

async function j(url, opts={}) {
  const r = await fetch(url, { headers: { "Content-Type": "application/json" }, ...opts });
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

const toTime = (ts) => {
  if (!ts) return null;
  const n = Number(ts);
  // support seconds OR ms epoch; support ISO strings
  if (!Number.isNaN(n)) {
    return new Date(n > 1e12 ? n : n * 1000);
  }
  return new Date(ts);
};
const fmtTime = (ts) => { const d = toTime(ts); return d ? d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : ''; };

const ensureArtPath = (url) => {
  if (!url) return DEFAULT_ART;
  // fix old frontends that requested "station-cover.jpg" with no /static
  if (url.endsWith("station-cover.jpg") && !url.includes("/static/")) return DEFAULT_ART;
  return url;
};

function getCover(ev) {
  if (ev.artwork_url && ev.artwork_url !== DEFAULT_ART) return ensureArtPath(ev.artwork_url);
  if (ev.filename) {
    const u = new URL('/api/cover', location.origin); u.searchParams.set('file', ev.filename); return u.toString();
  }
  return DEFAULT_ART;
}

function eventKey(e) {
  return (e.filename && e.filename.length > 0)
    ? `f|${e.filename}`
    : `t|${(e.title || '')}|${(e.artist || '')}|${(e.album || '')}`.toLowerCase() || `x|${e.time}`;
}

function setArtworkWithRetry(imgEl, ev, retries = 2) {
  const url = ensureArtPath(getCover(ev));
  const test = new Image();
  test.onload = () => { imgEl.src = url; };
  test.onerror = () => {
    if (retries > 0) setTimeout(() => setArtworkWithRetry(imgEl, ev, retries - 1), 500);
    else imgEl.src = DEFAULT_ART;
  };
  // cache-bust in case the same URL was cached as 404 by the browser
  test.src = url.includes('?') ? `${url}&v=${Date.now()}` : `${url}?v=${Date.now()}`;
}

async function enrichEventsWithArtwork(events) {
  for (const ev of events) {
    if (ev.type === 'song' && !ev.artwork_url && (ev.filename || (ev.title && ev.artist))) {
      try {
        if (ev.filename) {
  ev.artwork_url = `/api/cover?file=${encodeURIComponent(ev.filename)}`;
} else {
  // fallback to station cover
  ev.artwork_url = '/static/station-cover.jpg';
}
      } catch {}
    }
  }
  return events;
}

function sameTrack(a,b){
  if (!a || !b) return false;
  if (a.filename && b.filename && a.filename === b.filename) return true;
  const ta=(a.title||'').trim().toLowerCase(), tb=(b.title||'').trim().toLowerCase();
  const aa=(a.artist||'').trim().toLowerCase(), ab=(b.artist||'').trim().toLowerCase();
  return ta && tb && ta === tb && aa === ab;
}

let lastSig = '';
let lastLiveTrack = null;

async function loadTimeline(){
  try {
    if (window._timelineLoading) return; window._timelineLoading = true;
    
    // Clear any existing countdown timer
    if (window._currentCountdown) {
      clearInterval(window._currentCountdown);
      window._currentCountdown = null;
    }

    const [nowR, nextR, ttsR, histR, djStatusR] = await Promise.allSettled([
      j('/api/now'), j('/api/next'), j('/api/tts_queue'), j('/api/history'), j('/api/dj_status')
    ]);
    const now     = nowR.status==='fulfilled' ? nowR.value : {};
    const next    = nextR.status==='fulfilled' ? nextR.value : [];
    const tts     = ttsR.status==='fulfilled' ? ttsR.value : [];
    const history = histR.status==='fulfilled' ? histR.value : [];
    const djStatus = djStatusR.status==='fulfilled' ? djStatusR.value : {};

    // LIVE NOW
    const live = (now && (now.title || now.filename)) ? {
      ...now, type:'song', liveNow:true,
      title: now.title || 'Unknown Track', artist: now.artist || 'Unknown Artist'
    } : null;

    const currentLiveKey = live ? `${live.title}|${live.artist}` : null;
    const liveChanged = lastLiveTrack && lastLiveTrack !== currentLiveKey && currentLiveKey; if (currentLiveKey) lastLiveTrack = currentLiveKey;

    // UPCOMING
    let upcoming = Array.isArray(next) ? next : [];
    upcoming = upcoming
      .filter(s => !sameTrack(s, live))
      .map(s => ({ 
        type: s.type === 'dj' ? 'dj' : 'upcoming', 
        time: Date.now() + Math.random()*1e5, 
        title: s.title || 'Unknown title', 
        artist: s.artist || '', 
        album: s.album || '', 
        filename: s.filename || '', 
        text: s.text || '', 
        audio_url: s.audio_url || '', 
        artwork_url: ensureArtPath(s.artwork_url || getCover(s)) 
      }));

    // No client-side lookup; just ensure a usable cover URL or fallback
    upcoming = upcoming.map(t => {
      if (!t.artwork_url) t.artwork_url = ensureArtPath(getCover(t));
      return t;
    });

    // de-dupe upcoming by title|artist (but don't dedupe DJ intros as they may have different text)
    const seenU = new Set();
    upcoming = upcoming.filter(t=>{ 
      if (t.type === 'dj') {
        // For DJ intros, dedupe by text content instead of title/artist
        const k=`dj:${(t.text||'').toLowerCase()}`;
        if(seenU.has(k)) return false; 
        seenU.add(k); 
        return true;
      } else {
        // For songs, dedupe by title/artist as before
        const k=`${(t.title||'').toLowerCase()}|${(t.artist||'').toLowerCase()}`; 
        if(seenU.has(k)) return false; 
        seenU.add(k); 
        return true; 
      }
    });

    // HISTORY + DJ
    const events = [...(history||[])];
    (tts||[]).forEach(t=>{ const dj={...t,type:'dj',time:t.time||Date.now()}; const exists = events.find(e=> e.type==='dj' && e.text===dj.text && Math.abs((e.time||0)-(dj.time||0))<60000); if(!exists) events.push(dj); });
    events.sort((a,b)=> new Date(b.time) - new Date(a.time));

    const songEvents = await enrichEventsWithArtwork(events.filter(e=>e.type==='song'));
    const allEvents = [...songEvents, ...events.filter(e=>e.type==='dj')].sort((a,b)=> new Date(b.time) - new Date(a.time));

    const played = allEvents.filter(e => {
  if (e.type === 'dj') return true;
  if (e.type === 'song') {
    // Hide the currently live track, but keep everything else
    if (live && sameTrack(e, live)) return false;
  }
  return true;
});

    const seenP = new Set();
    const dedupedPlayed = played.filter(tr=>{
      if (tr.type==='dj') return true;
      const k=`${(tr.title||'').toLowerCase()}|${(tr.artist||'').toLowerCase()}`; if(seenP.has(k)) return false; seenP.add(k); return true;
    });

    const djSig = djStatus.current_generation ? `gen:${djStatus.current_generation.title}|${djStatus.current_generation.status}|${djStatus.current_generation.started_at}` : '' + (djStatus.recent_intros || []).map(i => `recent:${i.title}|${i.status}|${i.completed_at || i.started_at}`).join('||');
    const sig = dedupedPlayed.map(e=>[e.type||'song', e.filename||'', e.title||'', e.artist||'', e.artwork_url||'', Math.floor((e.time||0)/60000)].join('|')).join('||') + upcoming.map(u=>`up:${u.title}|${u.artist}|${u.artwork_url||'noart'}`).join('||') + (live?`|live:${live.title}|${live.artist}|${live.artwork_url||''}`:'') + `|dj:${djSig}`;
    if (sig === lastSig) { window._timelineLoading=false; return; } lastSig = sig;

    // --- render
    const box = $("timeline"); box.innerHTML = '';
    const h = (tag,cls,html='')=>{ const el=document.createElement(tag); if(cls) el.className=cls; if(html) el.innerHTML=html; return el; };
    const section = (title)=>{ const wrap=h('div',null); wrap.appendChild(h('div','event-meta',`<strong>${title}</strong>`)); return wrap; };

    // DJ Status Section
    if (djStatus.current_generation || (djStatus.recent_intros && djStatus.recent_intros.length > 0)) {
      const djSec = section('üéôÔ∏è DJ INTRO STATUS');
      
      // Add clear button
      const clearBtn = h('button', 'clear-dj-status-btn', '‚úï Clear');
      clearBtn.onclick = clearDjStatus;
      clearBtn.style.cssText = 'float:right; background:#ff5d5d; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:12px; margin-top:-2px;';
      djSec.firstChild.appendChild(clearBtn);
      
      // Current generation
      if (djStatus.current_generation) {
        const gen = djStatus.current_generation;
        const div = h('div', 'event dj generating');
        div.innerHTML = `
          <img alt="DJ" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIGZpbGw9IiM0ZGEzZmYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTIgMTRjMS42NiAwIDItMS4zNCAyLTNWNWMwLTEuNjYtLjM0LTMtMi0zUzEwIDMuMzQgMTAgNXY2YzAgMS42Ni4zNCAzIDIgM3ptNS41LTN2MWMwIDIuNzYtMi4yNCA1LTUgNXMtNS0yLjI0LTUtNXYtMUg1LjV2MWMwIDMuNTMgMi42MSA2LjQzIDYgNi45MlYyMGgtMnYxLjVoNi41VjIwaC0ydi0xLjA4YzMuMzktLjQ5IDYtMy4zOSA2LTYuOTJ2LTFoLTEuNXoiLz48L3N2Zz4=" loading="lazy">
          <div class="event-details">
            <div class="event-meta">
              <span>‚è≥ Generating...</span>
              <span class="voice-chip" style="background: #ffb020; color: #271400;">In Progress</span>
            </div>
            <div class="event-title">Generating DJ intro for "${gen.title}"</div>
            <div class="event-sub">by ${gen.artist} ‚Ä¢ Started ${Math.floor((Date.now() - gen.started_at * 1000) / 1000)}s ago</div>
          </div>`;
        djSec.appendChild(div);
      }
      
      // Recent intros
      if (djStatus.recent_intros && djStatus.recent_intros.length > 0) {
        for (const intro of djStatus.recent_intros.slice(0, 3)) {
          const div = h('div', `event dj ${intro.status}`);
          const statusIcon = intro.status === 'completed' ? '‚úÖ' : intro.status === 'failed' ? '‚ùå' : '‚è≥';
          const statusText = intro.status === 'completed' ? 'Ready' : intro.status === 'failed' ? 'Failed' : 'Processing';
          const statusColor = intro.status === 'completed' ? '#3ddc97' : intro.status === 'failed' ? '#ff5d5d' : '#ffb020';
          
          div.innerHTML = `
            <img alt="DJ" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIGZpbGw9IiM0ZGEzZmYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTIgMTRjMS42NiAwIDItMS4zNCAyLTNWNWMwLTEuNjYtLjM0LTMtMi0zUzEwIDMuMzQgMTAgNXY2YzAgMS42Ni4zNCAzIDIgM3ptNS41LTN2MWMwIDIuNzYtMi4yNCA1LTUgNXMtNS0yLjI0LTUtNXYtMUg1LjV2MWMwIDMuNTMgMi42MSA2LjQzIDYgNi45MlYyMGgtMnYxLjVoNi41VjIwaC0ydi0xLjA4YzMuMzktLjQ5IDYtMy4zOSA2LTYuOTJ2LTFoLTEuNXoiLz48L3N2Zz4=" loading="lazy">
            <div class="event-details">
              <div class="event-meta">
                <span>${statusIcon} ${statusText}</span>
                <span class="voice-chip" style="background: ${statusColor}; color: ${statusColor === '#3ddc97' ? '#0d2818' : statusColor === '#ff5d5d' ? '#2d0f0f' : '#271400'};">${statusText}</span>
              </div>
              <div class="event-title">DJ intro for "${intro.title}"</div>
              <div class="event-sub">by ${intro.artist}${intro.error ? ' ‚Ä¢ ' + intro.error : ''}</div>
            </div>`;
          djSec.appendChild(div);
        }
      }
      
      box.appendChild(djSec);
    }

    // Upcoming (songs and DJ intros)
    if (upcoming.length) {
      const sec = section('‚è≠Ô∏è UPCOMING');
      for (const ev of upcoming.slice(0,10)) {
        if (ev.type === 'dj') {
          // DJ Intro - show as commentary, not as upcoming track
          const div=h('div','event dj upcoming');
          div.innerHTML = `
            <div style="width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:var(--accent); border-radius:8px; color:white; font-size:24px;">üéôÔ∏è</div>
            <div class="event-details">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip" style="background:var(--accent); color:white;">DJ Intro</span></div>
              <div class="event-title" style="color:var(--accent);">AI DJ Commentary</div>
              <div class="event-sub">${ev.text || 'DJ intro for upcoming track'}</div>
            </div>`;
          sec.appendChild(div);
        } else {
          // Regular upcoming song
          const div=h('div','event upcoming song');
          div.innerHTML = `
            <img alt="Album artwork" loading="lazy" decoding="async">
            <div class="event-details">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip">Upcoming</span></div>
              <div class="event-title">${ev.title || 'Unknown title'}</div>
              <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
            </div>`;
          sec.appendChild(div);
          setArtworkWithRetry(div.querySelector('img'), ev);
        }
      }
      box.appendChild(sec);
    }

    // Live now
    if (live) {
      const sec = section('üî¥ LIVE NOW');
      const card=h('div','event song');
      card.innerHTML = `
        <img alt="Album artwork" loading="eager" decoding="sync">
        <div class="event-details">
          <div class="event-meta"><span>${fmtTime(live.time)}</span><span class="live-chip">LIVE NOW</span><span class="voice-chip" id="remainChip">${live.remaining_seconds ? Math.ceil(live.remaining_seconds) + 's left' : '‚Äî'}</span></div>
          <div class="event-title">${live.title || 'Unknown title'}</div>
          <div class="event-sub">${[live.artist, live.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
        </div>`;
      sec.appendChild(card); box.appendChild(sec);
      setArtworkWithRetry(card.querySelector('img'), live);
      
      // Start countdown timer for remaining time
      if (live.remaining_seconds && live.remaining_seconds > 0) {
        const startTime = Date.now();
        const initialRemaining = live.remaining_seconds;
        
        const updateCountdown = () => {
          const elapsed = (Date.now() - startTime) / 1000;
          const remaining = Math.max(0, initialRemaining - elapsed);
          const chip = document.getElementById('remainChip');
          if (chip) {
            if (remaining > 0) {
              chip.textContent = Math.ceil(remaining) + 's left';
              chip.style.background = remaining < 30 ? '#ff5d5d' : remaining < 60 ? '#ffb020' : '#3ddc97';
              chip.style.color = remaining < 30 ? '#2d0f0f' : remaining < 60 ? '#271400' : '#0d2818';
            } else {
              chip.textContent = 'Ending soon...';
              chip.style.background = '#ff5d5d';
              chip.style.color = '#2d0f0f';
            }
          }
        };
        
        // Update immediately and then every second
        updateCountdown();
        const countdownInterval = setInterval(() => {
          updateCountdown();
          // Stop countdown when time runs out
          const elapsed = (Date.now() - startTime) / 1000;
          if (elapsed >= initialRemaining + 10) { // Give 10s buffer
            clearInterval(countdownInterval);
          }
        }, 1000);
        
        // Store interval ID to clear on next timeline refresh
        window._currentCountdown = countdownInterval;
      }
    }

    // Just played
    const sec = section('üìÄ JUST PLAYED');
    if (dedupedPlayed.length) {
      for (const ev of dedupedPlayed) {
        const div=h('div',`event ${ev.type||'song'}`);
        if (ev.type==='dj') {
          div.innerHTML = `
            <div class="event-details" style="width:100%">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip">DJ Intro</span></div>
              <div class="event-title">üéôÔ∏è ${ev.text || '(DJ line)'}</div>
              ${ev.audio_url ? `<audio controls preload="none" src="${ev.audio_url}" style="margin-top:8px; width:100%"></audio>` : ''}
            </div>`;
        } else {
          div.innerHTML = `
            <img alt="Album artwork" loading="lazy" decoding="async">
            <div class="event-details">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span></div>
              <div class="event-title">${ev.title || 'Unknown title'}</div>
              <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
            </div>`;
          setArtworkWithRetry(div.querySelector('img'), ev);
        }
        sec.appendChild(div);
      }
    } else {
      const empty=h('div','event-meta'); empty.innerHTML = '<em>No tracks played yet. Songs will appear here as they play.</em>'; sec.appendChild(empty);
    }
    box.appendChild(sec);

  } catch (e) {
    console.error(e);
    $("timeline").innerHTML = '<div class="event-meta" style="text-align:center; padding:20px"><strong>Unable to load timeline</strong><br>Retrying in a few seconds...</div>';
  } finally {
    window._timelineLoading = false;
  }
}

$('skipBtn').onclick = async () => { try{ await j('/api/skip',{method:'POST'}); loadTimeline(); } catch(e){} };

loadTimeline();
setInterval(loadTimeline, 10000);
</script>
</body>
</html>

<script>
async function clearDjStatus() {
  try {
    const response = await fetch('/api/dj_status/clear', { 
      method: 'POST',
      headers: {'Content-Type': 'application/json'}
    });
    
    if (response.ok) {
      // Reload timeline to refresh display
      loadTimeline();
    } else {
      console.error('Failed to clear DJ status');
    }
  } catch (e) {
    console.error('Error clearing DJ status:', e);
  }
}

async function loadTtsSettings() {
  try {
    const r = await fetch('/api/settings', {cache:'no-store'});
    const data = await r.json();
    const sel = document.getElementById('ttsProvider');
    if (sel && data && data.tts_provider) sel.value = data.tts_provider;
  } catch (e) { console.error('loadTtsSettings', e); }
}

async function saveTtsProvider() {
  const sel = document.getElementById('ttsProvider');
  const badge = document.getElementById('ttsSaveStatus');
  if (!sel) return;
  const val = sel.value;
  try {
    badge && (badge.textContent = 'Saving‚Ä¶');
    const r = await fetch('/api/settings', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ tts_provider: val })
    });
    const j = await r.json();
    if (j && j.ok) {
      badge && (badge.textContent = 'Saved');
      setTimeout(()=>{ if (badge) badge.textContent=''; }, 1200);
    } else {
      badge && (badge.textContent = 'Error');
      console.error('saveTtsProvider error', j);
    }
  } catch (e) {
    badge && (badge.textContent = 'Error');
    console.error('saveTtsProvider', e);
  }
}

document.addEventListener('change', (ev)=>{
  if (ev.target && ev.target.id === 'ttsProvider') saveTtsProvider();
});

// Ensure it loads with the rest of the dashboard
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', loadTtsSettings);
} else {
  loadTtsSettings();
}
</script>
