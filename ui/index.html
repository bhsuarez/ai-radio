<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Radio</title>
<style>
  :root {
    --bg: #0f1115; --card:#171a22; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4da3ff;
    --ok:#3ddc97; --warn:#ffb020; --err:#ff5d5d; --radius:14px;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.4 system-ui, sans-serif; display:flex; height:100vh; }
  a { color:var(--accent); text-decoration:none; }

  /* Sidebar */
  .sidebar { width:260px; background:#13161d; border-right:1px solid #1f2531; display:flex; flex-direction:column; padding:16px; gap:12px; }
  .sidebar h1 { font-size:20px; margin:0 0 6px; }
  .btn { appearance:none; border:1px solid #2a2f3a; background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; text-align:left; }
  .btn:hover { border-color:#3a4150; }
  .btn.accent { background:var(--accent); border-color:var(--accent); color:#041427; }
  .btn.warn { background:var(--warn); border-color:var(--warn); color:#271400; }
  audio { width:100%; }

  /* Main */
  .main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
  header { padding:16px; border-bottom:1px solid #1f2531; display:flex; justify-content:space-between; align-items:center; }
  header .title { font-size:18px; font-weight:600; }
  .timeline { flex:1; overflow-y:auto; padding:16px; display:flex; flex-direction:column; gap:12px; }
  .event { background:var(--card); border-radius:var(--radius); padding:12px; border:1px solid #202634; display:flex; gap:12px; }
  .event.dj { border-left:4px solid var(--accent); }
  .event.song { border-left:4px solid var(--ok); }
  .event.upcoming { opacity:0.7; }
  .event img { width:60px; height:60px; border-radius:8px; object-fit:cover; background:#0b0d12; border:1px solid #1f2531; }
  .event-details { flex:1; }
  .event-meta { font-size:12px; color:var(--muted); margin-bottom:4px; display:flex; gap:8px; flex-wrap:wrap; }
  .voice-chip { padding:2px 6px; border-radius:999px; border:1px solid #1f2531; background:#0f1420; font-size:11px; color:var(--muted); }
  .event-title { font-weight:600; }
  .event-sub { font-size:14px; color:var(--muted); }
  .live-chip {
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    background:#ff4d4d;
    color:white;
    font-size:11px;
    font-weight:bold;
    margin-right:6px;
  }

  /* Mobile styles */
  @media (max-width: 768px) {
    body { flex-direction:column; }
    .sidebar {
      flex-direction:row;
      flex-wrap:wrap;
      width:100%;
      border-right:none;
      border-bottom:1px solid #1f2531;
      align-items:center;
      gap:8px;
    }
    .sidebar h1 { flex:1 1 100%; margin-bottom:4px; }
    .btn { flex:1; font-size:14px; padding:8px; text-align:center; }
    audio { position:sticky; top:0; z-index:10; background:#13161d; }
    .timeline { padding:8px; }
  }
</style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>üéß AI Radio</h1>
    <a class="btn" id="openLink" href="#" target="_blank" rel="noopener">üîó Open Stream</a>
    <a class="btn" href="http://icecast.zorro.local:8000" target="_blank">üìä Icecast Admin</a>
    <audio id="livePlayer" controls preload="none"></audio>
    <button class="btn warn" id="skipBtn">‚è≠Ô∏è Skip Track</button>
    <button class="btn accent" id="genBtn">‚ú® Generate DJ Line</button>
  </aside>

  <!-- Main content -->
  <div class="main">
    <header>
      <div class="title">üìú Live Timeline</div>
    </header>
    <div id="timeline" class="timeline"></div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = (id) => document.getElementById(id);
  const STREAM_URL = "http://icecast.zorro.local:8000/stream.mp3";
  $('livePlayer').src = STREAM_URL;
  $('livePlayer').load();
  $('openLink').href = STREAM_URL;

  // ------- fetch helper
  async function j(url,opts={}) {
    const r = await fetch(url,{headers:{'Content-Type':'application/json'},...opts});
    if(!r.ok) throw new Error(await r.text());
    return r.json();
  }
  const fmtTime = (ts) => ts ? new Date(ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';

// Enhanced cover helpers with better DOM update handling
function getCover(ev) {
  // Always try the extracted artwork first
  if (ev.artwork_url && ev.artwork_url !== '/static/station-cover.jpg') {
    return ev.artwork_url;
  }

  // If we have a filename, try to get cover from it
  if (ev.filename) {
    const u = new URL('/api/cover', location.origin);
    u.searchParams.set('file', ev.filename);
    return u.toString();
  }

  return '/static/station-cover.jpg';
}

function eventKey(e) {
  return (e.filename && e.filename.length > 0)
    ? `f|${e.filename}`
    : `t|${(e.title || '')}|${(e.artist || '')}|${(e.album || '')}`.toLowerCase() || `x|${e.time}`;
}

const lastArtByKey = new Map();
const failedUrls = new Set();

// Enhanced setCoverOnce that forces image reload on DOM updates
function setCoverOnce(imgEl, ev) {
  if (!imgEl || !ev) return;

  const key = eventKey(ev);
  const url = getCover(ev);

  console.log(`Setting cover for ${ev.title} - ${ev.artist}: ${url}`);

  // Skip if we've already tried this URL and it failed
  if (failedUrls.has(url)) {
    console.log(`URL previously failed: ${url}`);
    imgEl.src = '/static/station-cover.jpg';
    return;
  }

  // ALWAYS set the src, even if we think it's the same
  // This fixes the issue where DOM updates break image references
  console.log(`Force loading image: ${url}`);
  imgEl.src = url;
  lastArtByKey.set(key, url);

  // Set up error/load handlers if not already bound
  if (!imgEl._fallbackBound) {
    imgEl.onerror = function() {
      console.error(`Image failed to load: ${this.src}`);
      this.onerror = null;
      failedUrls.add(url);
      this.src = '/static/station-cover.jpg';
    };
    imgEl.onload = function() {
      console.log(`Image loaded successfully: ${this.src}`);
      // If it loaded successfully, remove from failed set
      failedUrls.delete(url);
    };
    imgEl._fallbackBound = true;
  }

  // Force the browser to actually load the image
  if (imgEl.complete && imgEl.naturalHeight === 0) {
    // Image failed to load, trigger error handler
    imgEl.onerror();
  }
}

// Enhanced function to set artwork with retry logic
function setArtworkWithRetry(imgEl, ev, retries = 2) {
  if (!imgEl || !ev) return;

  const url = getCover(ev);

  // Create a new image to test if URL is valid
  const testImg = new Image();
  testImg.onload = function() {
    // URL is valid, set it on the actual element
    imgEl.src = url;
    console.log(`Artwork verified and set: ${url}`);
  };
  testImg.onerror = function() {
    console.warn(`Artwork failed to load: ${url}`);
    if (retries > 0) {
      // Retry after a short delay
      setTimeout(() => {
        setArtworkWithRetry(imgEl, ev, retries - 1);
      }, 1000);
    } else {
      // Use fallback
      imgEl.src = '/static/station-cover.jpg';
    }
  };
  testImg.src = url;
}

// Force refresh artwork for all events by ensuring they have artwork_url
async function enrichEventsWithArtwork(events) {
  console.log(`Enriching ${events.length} events with artwork...`);

  for (const ev of events) {
    if (ev.type === 'song' && !ev.artwork_url && (ev.filename || (ev.title && ev.artist))) {
      try {
        // For events without artwork_url, try to get it
        if (ev.filename) {
          ev.artwork_url = `/api/cover?file=${encodeURIComponent(ev.filename)}`;
        } else if (ev.title && ev.artist) {
          // Try to find the file for this track
          const response = await fetch(`/api/test_find?title=${encodeURIComponent(ev.title)}&artist=${encodeURIComponent(ev.artist)}`);
          if (response.ok) {
            const result = await response.json();
            if (result.found_file && result.has_artwork) {
              ev.artwork_url = result.artwork_url;
              ev.filename = result.found_file; // Cache the filename too
              console.log(`Found artwork for ${ev.title}: ${ev.artwork_url}`);
            }
          }
        }
      } catch (error) {
        console.warn(`Failed to enrich artwork for ${ev.title}:`, error);
      }
    }
  }

  return events;
}

  // ------- localStorage cache so hiccups don't wipe art
  const CACHE_KEY = 'ai-radio:timeline-cache:v2';
  const loadCache = () => { try { return JSON.parse(localStorage.getItem(CACHE_KEY) || '[]'); } catch { return []; } };
  const saveCache = (evts) => { try { localStorage.setItem(CACHE_KEY, JSON.stringify(evts.slice(0,200))); } catch {} };
  function mergeWithCache(newEvents){
    const old = loadCache();
    const byK = new Map(old.map(e => [eventKey(e), e]));
    return newEvents.map(e => {
      const k = eventKey(e);
      const prev = byK.get(k);
      // keep previous art if new one is missing or default
      if (prev && (!e.artwork_url || e.artwork_url.endsWith('/station-cover.jpg'))) {
        e.artwork_url = prev.artwork_url;
      }
      return e;
    });
  }

// Complete working loadTimeline function
let lastLiveTrack = null;

async function loadTimeline() {
  try {
    console.log('Loading timeline...');

    // Add a small lock to prevent overlapping timeline updates
    if (window._timelineLoading) {
      console.log('Timeline already loading, skipping...');
      return;
    }
    window._timelineLoading = true;

    try {
      const [now, next, tts, history] = await Promise.all([
        j('/api/now'),
        j('/api/next'),
        j('/api/tts_queue'),
        j('/api/history')
      ]);

      console.log('API responses:', {
        now: now?.title || 'No title',
        nextCount: next?.length,
        ttsCount: tts?.length,
        historyCount: history?.length
      });

      function sameTrack(a, b) {
        if (!a || !b) return false;

        if (a.filename && b.filename && a.filename === b.filename) {
          return true;
        }

        const ta = (a.title || '').toLowerCase().trim();
        const aa = (a.artist || '').toLowerCase().trim();
        const tb = (b.title || '').toLowerCase().trim();
        const ab = (b.artist || '').toLowerCase().trim();

        if (ta && tb && ta.length > 2 && tb.length > 2) {
          return ta === tb && aa === ab;
        }

        return false;
      }

      // Build LIVE with better fallback handling
      const live = (now && (now.title || now.filename)) ? {
        ...now,
        type: 'song',
        liveNow: true,
        title: now.title || 'Unknown Track',
        artist: now.artist || 'Unknown Artist'
      } : null;

      // Track change detection
      const currentLiveTrack = live ? `${live.title}|${live.artist}` : null;
      const liveTrackChanged = lastLiveTrack && lastLiveTrack !== currentLiveTrack && currentLiveTrack;

      if (liveTrackChanged) {
        console.log('Live track changed! Will refresh upcoming artwork...');
      }

      if (currentLiveTrack) {
        lastLiveTrack = currentLiveTrack;
      }

      // Build upcoming
      let upcoming = [];
      try {
        upcoming = (next || [])
          .filter(s => !sameTrack(s, live))
          .map(s => ({
            type: 'upcoming',
            time: Date.now() + Math.random() * 100000,
            title: s.title || 'Unknown title',
            artist: s.artist || '',
            album: s.album || '',
            filename: s.filename || '',
            artwork_url: s.artwork_url || getCover(s)
          }));
      } catch (error) {
        console.error('Error processing upcoming tracks:', error);
      }

      // Enhanced artwork refresh
      const shouldForceArtworkRefresh = liveTrackChanged || upcoming.some(t =>
        !t.artwork_url || t.artwork_url === '/static/station-cover.jpg'
      );

      if (shouldForceArtworkRefresh && upcoming.length > 0) {
        console.log('Refreshing upcoming artwork...');

        try {
          const artworkPromises = upcoming.map(async (track, index) => {
            if (!track.artwork_url || track.artwork_url === '/static/station-cover.jpg') {
              if (track.title && track.artist && track.title !== 'Unknown title') {
                try {
                  await new Promise(resolve => setTimeout(resolve, index * 100));

                  const response = await fetch(`/api/test_find?title=${encodeURIComponent(track.title)}&artist=${encodeURIComponent(track.artist)}`);
                  if (response.ok) {
                    const result = await response.json();
                    if (result.found_file && result.has_artwork) {
                      track.artwork_url = result.artwork_url;
                      track.filename = result.found_file;
                      console.log(`‚úÖ Found artwork for: ${track.title}`);
                    }
                  }
                } catch (error) {
                  console.warn(`Failed to find artwork for ${track.title}:`, error);
                }
              }
            }
            return track;
          });

          upcoming = await Promise.race([
            Promise.all(artworkPromises),
            new Promise((resolve) => setTimeout(() => {
              console.warn('Artwork search timeout, using partial results');
              resolve(upcoming);
            }, 3000))
          ]);
        } catch (error) {
          console.error('Error during artwork refresh:', error);
        }
      }

      // Remove duplicates
      const seenUpcoming = new Set();
      upcoming = upcoming.filter(track => {
        const key = `${track.title.toLowerCase()}|${track.artist.toLowerCase()}`;
        if (seenUpcoming.has(key)) {
          return false;
        }
        seenUpcoming.add(key);
        return true;
      });

      // Process history events
      const events = [...(history || [])];

      try {
        (tts || []).forEach(t => {
          const dj = { ...t, type: 'dj', time: t.time || Date.now() };
          const existingDJ = events.find(e =>
            e.type === 'dj' &&
            e.text === dj.text &&
            Math.abs((e.time || 0) - (dj.time || 0)) < 60000
          );
          if (!existingDJ) {
            events.push(dj);
          }
        });
      } catch (error) {
        console.error('Error processing DJ events:', error);
      }

      events.sort((a, b) => new Date(b.time) - new Date(a.time));

      let enrichedEvents = [];
      try {
        enrichedEvents = await enrichEventsWithArtwork(events.filter(e => e.type === 'song'));
      } catch (error) {
        console.error('Error enriching events:', error);
        enrichedEvents = events.filter(e => e.type === 'song');
      }

      const allEvents = [
        ...enrichedEvents,
        ...events.filter(e => e.type === 'dj')
      ].sort((a, b) => new Date(b.time) - new Date(a.time));

      const played = allEvents.filter(e => {
        if (e.type === 'dj') return true;
        if (e.type === 'song') {
          if (live && sameTrack(e, live)) return false;
          const matchesUpcoming = upcoming.some(u => sameTrack(e, u));
          if (matchesUpcoming) return false;
        }
        return true;
      });

      const seenPlayed = new Set();
      const dedupedPlayed = played.filter(track => {
        if (track.type === 'dj') return true;
        if (track.type === 'song') {
          const key = `${(track.title || '').toLowerCase()}|${(track.artist || '').toLowerCase()}`;
          if (seenPlayed.has(key)) return false;
          seenPlayed.add(key);
        }
        return true;
      });

      // Create stable signature
      const sigParts = dedupedPlayed.map(e => [
        e.type || 'song',
        e.type === 'dj' ? (e.text || '').substring(0, 50) : e.filename || '',
        e.title || '',
        e.artist || '',
        e.artwork_url || '',
        Math.floor((e.time || 0) / 60000)
      ].join('|'));
      const sig = sigParts.join('||') +
                  upcoming.map(u => `up:${u.title}|${u.artist}|${u.artwork_url || 'noart'}`).join('||') +
                  (live ? `|live:${live.title}|${live.artist}|${live.artwork_url}` : '');

      window._lastSig = window._lastSig || '';
      if (sig === window._lastSig) {
        console.log('Timeline unchanged, skipping render');
        return;
      }
      window._lastSig = sig;

      // RENDER THE TIMELINE
      const box = $('timeline');
      box.innerHTML = '';

      function h(tag, cls, html = '') {
        const el = document.createElement(tag);
        if (cls) el.className = cls;
        if (html) el.innerHTML = html;
        return el;
      }

      function section(title) {
        const wrap = h('div', null);
        wrap.appendChild(h('div', 'event-meta', `<strong>${title}</strong>`));
        return wrap;
      }

      function fmtRemaining(ms) {
        const s = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(s / 60), ss = String(s % 60).padStart(2, '0');
        return `${m}:${ss}`;
      }

      function computeRemaining(nowObj) {
        const nowTs = Date.now();
        if (typeof nowObj?.remaining_ms === 'number') return nowObj.remaining_ms;
        if (typeof nowObj?.duration_ms === 'number' && typeof nowObj?.elapsed_ms === 'number')
          return nowObj.duration_ms - nowObj.elapsed_ms;
        if (nowObj?.end_time) return new Date(nowObj.end_time).getTime() - nowTs;
        if (nowObj?.started_at && nowObj?.duration_ms)
          return nowObj.duration_ms - (nowTs - new Date(nowObj.started_at).getTime());
        return null;
      }

      // 1. UPCOMING (First)
      if (upcoming.length) {
        const sec = section('‚è≠Ô∏è UPCOMING');
        for (const ev of upcoming.slice(0, 10)) {
          const div = h('div', 'event upcoming song');
          div.innerHTML = `
            <img alt="Album artwork" loading="lazy" decoding="async" style="background: #0b0d12;">
            <div class="event-details">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip">Upcoming</span></div>
              <div class="event-title">${ev.title || 'Unknown title'}</div>
              <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
            </div>`;
          sec.appendChild(div);

          const img = div.querySelector('img');
          if (ev.artwork_url && ev.artwork_url !== '/static/station-cover.jpg') {
            setArtworkWithRetry(img, ev);
          } else {
            img.src = '/static/station-cover.jpg';
          }
        }
        box.appendChild(sec);
      }

      // 2. LIVE NOW (Second)
      if (live) {
        const sec = section('üî¥ LIVE NOW');
        const card = h('div', `event song`);
        card.innerHTML = `
          <img alt="Album artwork" loading="eager" decoding="sync" style="background: #0b0d12;">
          <div class="event-details">
            <div class="event-meta">
              <span>${fmtTime(live.time)}</span>
              <span class="live-chip">LIVE NOW</span>
              <span class="voice-chip" id="remainChip">--:--</span>
            </div>
            <div class="event-title">${live.title || 'Unknown title'}</div>
            <div class="event-sub">${[live.artist, live.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
          </div>`;
        sec.appendChild(card);
        box.appendChild(sec);

        const img = card.querySelector('img');
        setArtworkWithRetry(img, live);

        let remain = computeRemaining(live);
        const chip = card.querySelector('#remainChip');
        if (remain != null) {
          chip.textContent = `${fmtRemaining(remain)} left`;
          const t = setInterval(() => {
            remain -= 1000;
            if (remain <= 0) { chip.textContent = 'ending‚Ä¶'; clearInterval(t); return; }
            chip.textContent = `${fmtRemaining(remain)} left`;
          }, 1000);
        } else {
          chip.textContent = '‚Äî';
        }
      }

      // 3. JUST PLAYED (Third)
      if (dedupedPlayed.length) {
        const sec = section('üìÄ JUST PLAYED');
        for (const ev of dedupedPlayed) {
          const div = h('div', `event ${ev.type || 'song'}`);
          if (ev.type === 'dj') {
            div.innerHTML = `
              <div class="event-details" style="width:100%">
                <div class="event-meta">
                  <span>${fmtTime(ev.time)}</span>
                  <span class="voice-chip">DJ Intro</span>
                </div>
                <div class="event-title">üéôÔ∏è ${ev.text || '(DJ line)'}</div>
                ${ev.audio_url ? `<audio controls preload="none" src="${ev.audio_url}" style="margin-top: 8px; width: 100%;"></audio>` : ''}
              </div>`;
          } else {
            div.innerHTML = `
              <img alt="Album artwork" loading="lazy" decoding="async" style="background: #0b0d12;">
              <div class="event-details">
                <div class="event-meta"><span>${fmtTime(ev.time)}</span></div>
                <div class="event-title">${ev.title || 'Unknown title'}</div>
                <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
              </div>`;

            const img = div.querySelector('img');
            setTimeout(() => setArtworkWithRetry(img, ev), 100);
          }
          sec.appendChild(div);
        }
        box.appendChild(sec);
      } else {
        const sec = section('üìÄ JUST PLAYED');
        const emptyDiv = h('div', 'event-meta');
        emptyDiv.innerHTML = '<em>No tracks played yet. Songs will appear here as they play.</em>';
        sec.appendChild(emptyDiv);
        box.appendChild(sec);
      }

      console.log('Timeline rendered successfully');

    } finally {
      window._timelineLoading = false;
    }

  } catch (e) {
    console.error('Timeline load error:', e);
    window._timelineLoading = false;

    // Fallback: show error state
    const box = $('timeline');
    box.innerHTML = '<div class="event-meta" style="text-align: center; padding: 20px;"><strong>Unable to load timeline</strong><br>Retrying in a few seconds...</div>';
  }
}

  $('skipBtn').onclick = async () => { try{ await j('/api/skip',{method:'POST'}); loadTimeline(); } catch(e){} };
  // Enhanced DJ button handler

// Enhanced DJ button handler that doesn't break the timeline
// Simple DJ button handler
$('genBtn').onclick = async () => {
  try {
    console.log('Generating DJ line...');

    const originalText = $('genBtn').textContent;
    $('genBtn').disabled = true;
    $('genBtn').textContent = 'Generating...';

    const result = await j('/api/dj-now', { method: 'POST' });
    console.log('DJ generation result:', result);

    // Show success
    $('genBtn').textContent = 'Generated!';
    $('genBtn').style.backgroundColor = '#3ddc97';

    // Reset after 2 seconds
    setTimeout(() => {
      $('genBtn').disabled = false;
      $('genBtn').textContent = originalText;
      $('genBtn').style.backgroundColor = '';
    }, 2000);

  } catch (e) {
    console.error('DJ generation error:', e);

    $('genBtn').textContent = 'Error!';
    $('genBtn').style.backgroundColor = '#ff5d5d';

    setTimeout(() => {
      $('genBtn').disabled = false;
      $('genBtn').textContent = '‚ú® Generate DJ Line';
      $('genBtn').style.backgroundColor = '';
    }, 2000);
  }
};

  loadTimeline();
  setInterval(loadTimeline, 10000);
});
</script>
</body>
</html>