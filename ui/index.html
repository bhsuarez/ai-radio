<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Radio</title>
<style>
  :root {
    --bg: #0f1115; --card:#171a22; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4da3ff;
    --ok:#3ddc97; --warn:#ffb020; --err:#ff5d5d; --radius:14px;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.4 system-ui, sans-serif; display:flex; height:100vh; }
  a { color:var(--accent); text-decoration:none; }

  /* Sidebar */
  .sidebar { width:260px; background:#13161d; border-right:1px solid #1f2531; display:flex; flex-direction:column; padding:16px; gap:12px; }
  .sidebar h1 { font-size:20px; margin:0 0 6px; }
  .btn { appearance:none; border:1px solid #2a2f3a; background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; text-align:left; }
  .btn:hover { border-color:#3a4150; }
  .btn.accent { background:var(--accent); border-color:var(--accent); color:#041427; }
  .btn.warn { background:var(--warn); border-color:var(--warn); color:#271400; }
  audio { width:100%; }

  /* Main */
  .main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
  header { padding:16px; border-bottom:1px solid #1f2531; display:flex; justify-content:space-between; align-items:center; }
  header .title { font-size:18px; font-weight:600; }
  .timeline { flex:1; overflow-y:auto; overflow-x:hidden; padding:16px; display:flex; flex-direction:column; gap:16px; max-height:calc(100vh - 120px); }
  
  /* Timeline sections */
  .timeline-section { background:var(--card); border-radius:var(--radius); border:1px solid #202634; overflow:hidden; }
  .section-header { padding:12px 16px; border-bottom:1px solid #202634; font-weight:600; font-size:14px; text-transform:uppercase; letter-spacing:0.5px; }
  .section-header.live { background:linear-gradient(135deg, #ff4d4d, #ff6b6b); color:white; }
  .section-header.upcoming { background:linear-gradient(135deg, #4da3ff, #6bb6ff); color:white; }
  .section-header.recent { background:linear-gradient(135deg, #3ddc97, #5ce1a6); color:white; }

  .event { padding:12px 16px; border-bottom:1px solid #202634; display:flex; gap:12px; }
  .event:last-child { border-bottom:none; }
  .event.highlighted { background:rgba(77, 163, 255, 0.1); }
  .event img { width:60px; height:60px; border-radius:8px; object-fit:cover; background:#0b0d12; border:1px solid #1f2531; flex-shrink:0; }
  .event-details { flex:1; min-width:0; }
  .event-meta { font-size:12px; color:var(--muted); margin-bottom:4px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .event-title { font-weight:600; margin-bottom:2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .event-sub { font-size:14px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  
  .chip { padding:2px 8px; border-radius:12px; font-size:11px; font-weight:500; }
  .chip.live { background:#ff4d4d; color:white; animation:pulse 2s infinite; }
  .chip.time-left { background:#4da3ff; color:white; }
  .chip.dj { background:#9b59b6; color:white; }
  .chip.upcoming { background:#6c757d; color:white; }

  @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.7; } }

  .empty-state { padding:20px; text-align:center; color:var(--muted); font-style:italic; }

  /* Mobile styles */
  @media (max-width: 768px) {
    body { flex-direction:column; }
    .sidebar {
      flex-direction:row; flex-wrap:wrap; width:100%; border-right:none;
      border-bottom:1px solid #1f2531; align-items:center; gap:8px;
    }
    .sidebar h1 { flex:1 1 100%; margin-bottom:4px; }
    .btn { flex:1; font-size:14px; padding:8px; text-align:center; }
    audio { position:sticky; top:0; z-index:10; background:#13161d; }
    .timeline { padding:8px; gap:12px; }
    .event { padding:8px 12px; }
    .event img { width:50px; height:50px; }
  }
</style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>üéß AI Radio</h1>
    <a class="btn" id="openLink" href="#" target="_blank" rel="noopener">üîó Open Stream</a>
    <a class="btn" href="http://icecast.zorro.local:8000" target="_blank">üìä Icecast Admin</a>
    <audio id="livePlayer" controls preload="none"></audio>
    <button class="btn warn" id="skipBtn">‚è≠Ô∏è Skip Track</button>
    <button class="btn accent" id="genBtn">‚ú® Generate DJ Line</button>
  </aside>

  <!-- Main content -->
  <div class="main">
    <header>
      <div class="title">üìú Live Timeline</div>
      <div id="statusIndicator" style="font-size:12px; color:var(--muted);"></div>
    </header>
    <div id="timeline" class="timeline"></div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = (id) => document.getElementById(id);
  const STREAM_URL = "http://icecast.zorro.local:8000/stream.mp3";
  $('livePlayer').src = STREAM_URL;
  $('livePlayer').load();
  $('openLink').href = STREAM_URL;

  // Fetch helper
  async function j(url, opts = {}) {
    const r = await fetch(url, { headers: { 'Content-Type': 'application/json' }, ...opts });
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  }

  const fmtTime = (ts) => ts ? new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

  // Track comparison functions
  function tracksEqual(a, b) {
    if (!a || !b) return false;
    
    // Exact filename match is most reliable
    if (a.filename && b.filename && a.filename === b.filename) {
      return true;
    }
    
    // Title/artist match with some fuzzy logic
    const titleA = (a.title || '').toLowerCase().trim();
    const titleB = (b.title || '').toLowerCase().trim();
    const artistA = (a.artist || '').toLowerCase().trim();
    const artistB = (b.artist || '').toLowerCase().trim();
    
    if (titleA && titleB && titleA.length > 2 && titleB.length > 2) {
      return titleA === titleB && artistA === artistB;
    }
    
    return false;
  }

  function getTrackKey(track) {
    if (track.filename) return `file:${track.filename}`;
    const title = (track.title || '').toLowerCase().trim();
    const artist = (track.artist || '').toLowerCase().trim();
    return `track:${title}|${artist}`;
  }

  // Cover art helpers
  function getCoverUrl(track) {
    if (track.artwork_url && !track.artwork_url.endsWith('/station-cover.jpg')) {
      return track.artwork_url;
    }
    if (track.filename) {
      return `/api/cover?file=${encodeURIComponent(track.filename)}`;
    }
    return '/static/station-cover.jpg';
  }

  function setCoverImage(imgEl, track) {
    if (!imgEl || !track) return;
    
    const url = getCoverUrl(track);
    imgEl.src = '/static/station-cover.jpg'; // Start with default
    
    if (url !== '/static/station-cover.jpg') {
      const testImg = new Image();
      testImg.onload = () => imgEl.src = url;
      testImg.onerror = () => {}; // Keep default on error
      testImg.src = url;
    }
  }

  // Timeline state
  let lastSignature = '';
  let updateTimer = null;

  async function loadTimeline() {
    try {
      const statusEl = $('statusIndicator');
      statusEl.textContent = 'Loading...';

      console.log('Fetching timeline data...');

      // Fetch all data with better error handling
      const [nowData, nextData, historyData] = await Promise.all([
        j('/api/now').catch(e => { console.error('Now API error:', e); return null; }),
        j('/api/next').catch(e => { console.error('Next API error:', e); return []; }),
        j('/api/history').catch(e => { console.error('History API error:', e); return []; })
      ]);

      console.log('API Data received:', {
        nowData: nowData,
        nextCount: nextData?.length || 0,
        historyCount: historyData?.length || 0
      });

      statusEl.textContent = `Updated ${new Date().toLocaleTimeString()}`;

      // Process current track - be more lenient
      const currentTrack = nowData ? {
        ...nowData,
        type: 'song',
        time: nowData.time || Date.now(),
        title: nowData.title || nowData.song || 'Unknown Track',
        artist: nowData.artist || 'Unknown Artist',
        album: nowData.album || '',
        filename: nowData.filename || ''
      } : null;

      console.log('Current track:', currentTrack);

      // Process upcoming tracks - simplified filtering
      const upcomingTracks = (nextData || [])
        .slice(0, 10) // Limit upcoming tracks
        .map((track, index) => ({
          type: 'upcoming',
          time: Date.now() + (index + 1) * 180000, // 3 min apart estimates
          title: track.title || track.song || 'Unknown Track',
          artist: track.artist || 'Unknown Artist', 
          album: track.album || '',
          filename: track.filename || '',
          artwork_url: track.artwork_url
        }));

      console.log('Upcoming tracks:', upcomingTracks.length);

      // Process history - keep it simple for now
      const historyTracks = (historyData || [])
        .sort((a, b) => (b.time || 0) - (a.time || 0)) // Sort by time, newest first
        .slice(0, 20); // Limit to recent items

      console.log('History tracks:', historyTracks.length);

      // Always render, even if data seems the same
      renderTimeline(currentTrack, upcomingTracks, historyTracks);

    } catch (error) {
      console.error('Timeline load error:', error);
      $('statusIndicator').textContent = 'Error loading';
      
      // Show error state with more details
      const timeline = $('timeline');
      timeline.innerHTML = `
        <div class="timeline-section">
          <div class="section-header">‚ùå Error Loading Timeline</div>
          <div class="empty-state">
            Error: ${error.message}<br>
            Check console for details. Retrying in 10 seconds...
          </div>
        </div>
      `;
    }
  }

  function renderTimeline(currentTrack, upcomingTracks, historyItems) {
    const timeline = $('timeline');
    timeline.innerHTML = '';

    console.log('Rendering timeline with:', {
      current: currentTrack?.title || 'none',
      upcoming: upcomingTracks.length,
      history: historyItems.length
    });

    // Helper to create elements
    function createElement(tag, className = '', innerHTML = '') {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      return el;
    }

    function createSection(title, className, items, renderer) {
      const section = createElement('div', 'timeline-section');
      const header = createElement('div', `section-header ${className}`, title);
      section.appendChild(header);

      console.log(`Creating section ${title} with ${items.length} items`);

      if (items.length === 0) {
        const empty = createElement('div', 'empty-state', 
          className === 'upcoming' ? 'No upcoming tracks in queue' :
          className === 'recent' ? 'No tracks played recently' :
          'No data available'
        );
        section.appendChild(empty);
      } else {
        items.forEach((item, index) => {
          try {
            const eventEl = renderer(item, index);
            section.appendChild(eventEl);
          } catch (e) {
            console.error(`Error rendering item ${index}:`, e, item);
          }
        });
      }

      return section;
    }

    function formatRemaining(ms) {
      if (ms <= 0) return 'ending...';
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes}:${seconds.toString().padStart(2, '0')} left`;
    }

    // 1. LIVE NOW Section
    if (currentTrack) {
      const section = createSection('üî¥ LIVE NOW', 'live', [currentTrack], (track) => {
        const event = createElement('div', 'event highlighted');
        event.innerHTML = `
          <img alt="Album artwork" src="/static/station-cover.jpg">
          <div class="event-details">
            <div class="event-meta">
              <span>${fmtTime(track.time)}</span>
              <span class="chip live">LIVE</span>
              <span class="chip time-left" id="timeChip">playing</span>
            </div>
            <div class="event-title">${track.title || 'Unknown Track'}</div>
            <div class="event-sub">${[track.artist, track.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown Artist'}</div>
          </div>
        `;

        const img = event.querySelector('img');
        setCoverImage(img, track);

        // Handle remaining time
        const timeChip = event.querySelector('#timeChip');
        if (track.duration_ms && track.elapsed_ms) {
          let remaining = track.duration_ms - track.elapsed_ms;
          timeChip.textContent = formatRemaining(remaining);
          
          const interval = setInterval(() => {
            remaining -= 1000;
            if (remaining <= 0) {
              timeChip.textContent = 'ending...';
              clearInterval(interval);
            } else {
              timeChip.textContent = formatRemaining(remaining);
            }
          }, 1000);
        }

        return event;
      });
      timeline.appendChild(section);
    } else {
      // Show empty current section
      const section = createSection('üî¥ LIVE NOW', 'live', [], () => {});
      timeline.appendChild(section);
    }

    // 2. UPCOMING Section
    const upcomingSection = createSection('‚è≠Ô∏è UPCOMING', 'upcoming', upcomingTracks.slice(0, 8), (track) => {
      const event = createElement('div', 'event');
      event.innerHTML = `
        <img alt="Album artwork" src="/static/station-cover.jpg">
        <div class="event-details">
          <div class="event-meta">
            <span class="chip upcoming">Up Next</span>
          </div>
          <div class="event-title">${track.title || 'Unknown Track'}</div>
          <div class="event-sub">${[track.artist, track.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown Artist'}</div>
        </div>
      `;

      const img = event.querySelector('img');
      setCoverImage(img, track);
      return event;
    });
    timeline.appendChild(upcomingSection);

    // 3. RECENTLY PLAYED Section
    const recentSection = createSection('üìÄ RECENTLY PLAYED', 'recent', historyItems.slice(0, 20), (item) => {
      const event = createElement('div', 'event');
      
      if (item.type === 'dj') {
        event.innerHTML = `
          <div class="event-details" style="width: 100%;">
            <div class="event-meta">
              <span>${fmtTime(item.time)}</span>
              <span class="chip dj">DJ</span>
            </div>
            <div class="event-title">üéôÔ∏è ${item.text || '(DJ announcement)'}</div>
            ${item.audio_url ? `<audio controls preload="none" src="${item.audio_url}" style="margin-top: 8px; width: 100%; max-width: 300px;"></audio>` : ''}
          </div>
        `;
      } else {
        event.innerHTML = `
          <img alt="Album artwork" src="/static/station-cover.jpg">
          <div class="event-details">
            <div class="event-meta">
              <span>${fmtTime(item.time)}</span>
            </div>
            <div class="event-title">${item.title || 'Unknown Track'}</div>
            <div class="event-sub">${[item.artist, item.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown Artist'}</div>
          </div>
        `;

        const img = event.querySelector('img');
        setCoverImage(img, item);
      }
      
      return event;
    });
    timeline.appendChild(recentSection);

    console.log('Timeline rendered successfully');
  }

  // Button handlers
  $('skipBtn').onclick = async () => {
    try {
      await j('/api/skip', { method: 'POST' });
      setTimeout(loadTimeline, 1000); // Reload after skip
    } catch (e) {
      console.error('Skip error:', e);
    }
  };

  $('genBtn').onclick = async () => {
    const btn = $('genBtn');
    const originalText = btn.textContent;
    
    try {
      btn.disabled = true;
      btn.textContent = 'Generating...';
      btn.style.backgroundColor = '#ffb020';

      const result = await j('/api/dj-now', { method: 'POST' });
      
      btn.textContent = result.ok ? 'Generated!' : 'Error!';
      btn.style.backgroundColor = result.ok ? '#3ddc97' : '#ff5d5d';
      
      if (result.ok) {
        setTimeout(loadTimeline, 1000); // Reload to show new DJ line
      }

    } catch (e) {
      console.error('DJ generation error:', e);
      btn.textContent = 'Error!';
      btn.style.backgroundColor = '#ff5d5d';
    } finally {
      setTimeout(() => {
        btn.disabled = false;
        btn.textContent = originalText;
        btn.style.backgroundColor = '';
      }, 3000);
    }
  };

  // Initialize
  loadTimeline();
  setInterval(loadTimeline, 10000); // Update every 10 seconds
});
</script>
</body>
</html>