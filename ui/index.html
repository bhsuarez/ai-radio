<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Radio</title>
<style>
  :root {
    --bg: #0f1115; --card:#171a22; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4da3ff;
    --ok:#3ddc97; --warn:#ffb020; --err:#ff5d5d; --radius:14px;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.4 system-ui, sans-serif; display:flex; height:100vh; }
  a { color:var(--accent); text-decoration:none; }

  /* Sidebar */
  .sidebar { width:260px; background:#13161d; border-right:1px solid #1f2531; display:flex; flex-direction:column; padding:16px; gap:12px; }
  .sidebar h1 { font-size:20px; margin:0 0 6px; }
  .btn { appearance:none; border:1px solid #2a2f3a; background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; text-align:left; }
  .btn:hover { border-color:#3a4150; }
  .btn.accent { background:var(--accent); border-color:var(--accent); color:#041427; }
  .btn.warn { background:var(--warn); border-color:var(--warn); color:#271400; }
  audio { width:100%; }

  /* Main */
  .main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
  header { padding:16px; border-bottom:1px solid #1f2531; display:flex; justify-content:space-between; align-items:center; }
  header .title { font-size:18px; font-weight:600; }
  .timeline { flex:1; overflow-y:auto; padding:16px; display:flex; flex-direction:column; gap:12px; }
  .event { background:var(--card); border-radius:var(--radius); padding:12px; border:1px solid #202634; display:flex; gap:12px; }
  .event.dj { border-left:4px solid var(--accent); }
  .event.song { border-left:4px solid var(--ok); }
  .event.upcoming { opacity:0.7; }
  .event img { width:60px; height:60px; border-radius:8px; object-fit:cover; background:#0b0d12; border:1px solid #1f2531; }
  .event-details { flex:1; }
  .event-meta { font-size:12px; color:var(--muted); margin-bottom:4px; display:flex; gap:8px; flex-wrap:wrap; }
  .voice-chip { padding:2px 6px; border-radius:999px; border:1px solid #1f2531; background:#0f1420; font-size:11px; color:var(--muted); }
  .event-title { font-weight:600; }
  .event-sub { font-size:14px; color:var(--muted); }
  .live-chip {
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    background:#ff4d4d;
    color:white;
    font-size:11px;
    font-weight:bold;
    margin-right:6px;
  }

  /* Mobile styles */
  @media (max-width: 768px) {
    body { flex-direction:column; }
    .sidebar {
      flex-direction:row;
      flex-wrap:wrap;
      width:100%;
      border-right:none;
      border-bottom:1px solid #1f2531;
      align-items:center;
      gap:8px;
    }
    .sidebar h1 { flex:1 1 100%; margin-bottom:4px; }
    .btn { flex:1; font-size:14px; padding:8px; text-align:center; }
    audio { position:sticky; top:0; z-index:10; background:#13161d; }
    .timeline { padding:8px; }
  }
</style>
</head>
<body>
  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>üéß AI Radio</h1>
    <a class="btn" id="openLink" href="#" target="_blank" rel="noopener">üîó Open Stream</a>
    <a class="btn" href="http://icecast.zorro.local:8000" target="_blank">üìä Icecast Admin</a>
    <audio id="livePlayer" controls preload="none"></audio>
    <button class="btn warn" id="skipBtn">‚è≠Ô∏è Skip Track</button>
    <button class="btn accent" id="genBtn">‚ú® Generate DJ Line</button>
  </aside>

  <!-- Main content -->
  <div class="main">
    <header>
      <div class="title">üìú Live Timeline</div>
    </header>
    <div id="timeline" class="timeline"></div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const $ = (id) => document.getElementById(id);
  const STREAM_URL = "http://icecast.zorro.local:8000/stream.mp3";
  $('livePlayer').src = STREAM_URL;
  $('livePlayer').load();
  $('openLink').href = STREAM_URL;

  // ------- fetch helper
  async function j(url,opts={}) {
    const r = await fetch(url,{headers:{'Content-Type':'application/json'},...opts});
    if(!r.ok) throw new Error(await r.text());
    return r.json();
  }
  const fmtTime = (ts) => ts ? new Date(ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '';

  // Enhanced cover helpers that force image loading
function getCover(ev) {
  // Always try the extracted artwork first
  if (ev.artwork_url && ev.artwork_url !== '/static/station-cover.jpg') {
    console.log(`Using artwork_url: ${ev.artwork_url}`);
    return ev.artwork_url;
  }
  
  // If we have a filename, try to get cover from it
  if (ev.filename) {
    const u = new URL('/api/cover', location.origin);
    u.searchParams.set('file', ev.filename);
    console.log(`Generated cover URL: ${u.toString()}`);
    return u.toString();
  }
  
  console.log('Using default cover');
  return '/static/station-cover.jpg';
}

function eventKey(e) {
  return (e.filename && e.filename.length > 0)
    ? `f|${e.filename}`
    : `t|${(e.title || '')}|${(e.artist || '')}|${(e.album || '')}`.toLowerCase() || `x|${e.time}`;
}

const lastArtByKey = new Map();
const failedUrls = new Set();

function setCoverOnce(imgEl, ev) {
  const key = eventKey(ev);
  const url = getCover(ev);
  
  console.log(`Setting cover for ${ev.title} - ${ev.artist}: ${url}`);
  
  // Skip if we've already tried this URL and it failed
  if (failedUrls.has(url)) {
    console.log(`URL previously failed: ${url}`);
    imgEl.src = '/static/station-cover.jpg';
    return;
  }
  
  const prev = lastArtByKey.get(key);
  if (prev !== url) {
    console.log(`Loading new image: ${url}`);
    imgEl.src = url;
    lastArtByKey.set(key, url);
  }
  
  if (!imgEl._fallbackBound) {
    imgEl.onerror = function() {
      console.error(`Image failed to load: ${this.src}`);
      this.onerror = null;
      failedUrls.add(url);
      this.src = '/static/station-cover.jpg';
    };
    imgEl.onload = function() {
      console.log(`Image loaded successfully: ${this.src}`);
      // If it loaded successfully, remove from failed set
      failedUrls.delete(url);
    };
    imgEl._fallbackBound = true;
  }
}

// Force refresh artwork for all events by ensuring they have artwork_url
async function enrichEventsWithArtwork(events) {
  console.log(`Enriching ${events.length} events with artwork...`);
  
  for (const ev of events) {
    if (ev.type === 'song' && !ev.artwork_url && (ev.filename || (ev.title && ev.artist))) {
      try {
        // For events without artwork_url, try to get it
        if (ev.filename) {
          ev.artwork_url = `/api/cover?file=${encodeURIComponent(ev.filename)}`;
        } else if (ev.title && ev.artist) {
          // Try to find the file for this track
          const response = await fetch(`/api/test_find?title=${encodeURIComponent(ev.title)}&artist=${encodeURIComponent(ev.artist)}`);
          if (response.ok) {
            const result = await response.json();
            if (result.found_file && result.has_artwork) {
              ev.artwork_url = result.artwork_url;
              ev.filename = result.found_file; // Cache the filename too
              console.log(`Found artwork for ${ev.title}: ${ev.artwork_url}`);
            }
          }
        }
      } catch (error) {
        console.warn(`Failed to enrich artwork for ${ev.title}:`, error);
      }
    }
  }
  
  return events;
}

  // ------- localStorage cache so hiccups don't wipe art
  const CACHE_KEY = 'ai-radio:timeline-cache:v2';
  const loadCache = () => { try { return JSON.parse(localStorage.getItem(CACHE_KEY) || '[]'); } catch { return []; } };
  const saveCache = (evts) => { try { localStorage.setItem(CACHE_KEY, JSON.stringify(evts.slice(0,200))); } catch {} };
  function mergeWithCache(newEvents){
    const old = loadCache();
    const byK = new Map(old.map(e => [eventKey(e), e]));
    return newEvents.map(e => {
      const k = eventKey(e);
      const prev = byK.get(k);
      // keep previous art if new one is missing or default
      if (prev && (!e.artwork_url || e.artwork_url.endsWith('/station-cover.jpg'))) {
        e.artwork_url = prev.artwork_url;
      }
      return e;
    });
  }

// Enhanced DJ event handling in loadTimeline
async function loadTimeline() {
  try {
    console.log('Loading timeline...');
    
    const [now, next, tts, history] = await Promise.all([
      j('/api/now'),
      j('/api/next'), 
      j('/api/tts_queue'),
      j('/api/history')
    ]);

    console.log('API responses:', { 
      now: now?.title, 
      nextCount: next?.length, 
      ttsCount: tts?.length, 
      historyCount: history?.length 
    });

    // Enhanced helper: decide if two tracks are the same
    function sameTrack(a, b) {
      if (!a || !b) return false;
      
      // First try filename comparison
      if (a.filename && b.filename && a.filename === b.filename) {
        return true;
      }
      
      // Then try title + artist comparison (case insensitive)
      const ta = (a.title || '').toLowerCase().trim();
      const aa = (a.artist || '').toLowerCase().trim();
      const tb = (b.title || '').toLowerCase().trim();
      const ab = (b.artist || '').toLowerCase().trim();
      
      // Both must have meaningful titles to compare
      if (ta && tb && ta.length > 2 && tb.length > 2) {
        return ta === tb && aa === ab;
      }
      
      return false;
    }

    // Build LIVE directly from /api/now
    const live = (now && (now.title || now.filename))
      ? { ...now, type: 'song', liveNow: true }
      : null;

    console.log('Live track:', live?.title, 'by', live?.artist);

    // Build upcoming with better deduplication
    let upcoming = (next || [])
      .filter(s => !sameTrack(s, live))
      .map(s => ({
        type: 'upcoming',
        time: Date.now() + Math.random() * 100000,
        title: s.title || 'Unknown title',
        artist: s.artist || '',
        album: s.album || '',
        filename: s.filename || '',
        artwork_url: s.artwork_url || getCover(s)
      }));

    // Remove duplicates from upcoming list
    const seenUpcoming = new Set();
    upcoming = upcoming.filter(track => {
      const key = `${track.title.toLowerCase()}|${track.artist.toLowerCase()}`;
      if (seenUpcoming.has(key)) {
        console.log(`Removing duplicate upcoming track: ${track.title} by ${track.artist}`);
        return false;
      }
      seenUpcoming.add(key);
      return true;
    });

    console.log(`Upcoming tracks after dedup: ${upcoming.length}`);

    // Assemble events for history - ENHANCED DJ HANDLING
    const events = [...(history || [])];

    // Add TTS/DJ events with better deduplication
    console.log(`Processing ${tts?.length || 0} TTS/DJ events`);
    (tts || []).forEach(t => {
      const dj = { 
        ...t, 
        type: 'dj',
        // Ensure we have a proper timestamp
        time: t.time || Date.now()
      };
      
      // Better DJ deduplication - check for similar DJ events
      const existingDJ = events.find(e => 
        e.type === 'dj' && 
        e.text === dj.text && 
        Math.abs((e.time || 0) - (dj.time || 0)) < 60000 // Within 1 minute
      );
      
      if (!existingDJ) {
        console.log(`Adding DJ event: ${dj.text?.substring(0, 50)}...`);
        events.push(dj);
      } else {
        console.log(`Skipping duplicate DJ event: ${dj.text?.substring(0, 30)}...`);
      }
    });

    // Newest first
    events.sort((a, b) => new Date(b.time) - new Date(a.time));

    console.log('Processed events:', events.length, 'Live track:', live?.title);

    // IMPORTANT: Enrich SONG events with artwork (not DJ events)
    const enrichedEvents = await enrichEventsWithArtwork(events.filter(e => e.type === 'song'));
    
    // Re-combine with DJ events
    const allEvents = [
      ...enrichedEvents,
      ...events.filter(e => e.type === 'dj')
    ].sort((a, b) => new Date(b.time) - new Date(a.time));
    
    console.log('Artwork enrichment complete');

    // Better deduplication for history - remove duplicates of live track and upcoming tracks
    const played = allEvents.filter(e => {
      // Always keep DJ events
      if (e.type === 'dj') return true;
      
      // For songs, check duplicates
      if (e.type === 'song') {
        // Don't show if it's the same as live track
        if (live && sameTrack(e, live)) {
          console.log(`Removing from history (matches live): ${e.title} by ${e.artist}`);
          return false;
        }
        
        // Don't show if it's in upcoming
        const matchesUpcoming = upcoming.some(u => sameTrack(e, u));
        if (matchesUpcoming) {
          console.log(`Removing from history (matches upcoming): ${e.title} by ${e.artist}`);
          return false;
        }
      }
      
      return true;
    });

    // Also deduplicate within the played list itself (songs only)
    const seenPlayed = new Set();
    const dedupedPlayed = played.filter(track => {
      // Always keep DJ events
      if (track.type === 'dj') return true;
      
      // Deduplicate songs only
      if (track.type === 'song') {
        const key = `${(track.title || '').toLowerCase()}|${(track.artist || '').toLowerCase()}`;
        if (seenPlayed.has(key)) {
          console.log(`Removing duplicate from history: ${track.title} by ${track.artist}`);
          return false;
        }
        seenPlayed.add(key);
      }
      
      return true;
    });

    console.log(`History events after dedup: ${dedupedPlayed.length} (${dedupedPlayed.filter(e => e.type === 'dj').length} DJ events)`);

    // Change signature to avoid pointless re-rendering
    const sigParts = dedupedPlayed.map(e => [
      e.type || 'song',
      e.type === 'dj' ? (e.text || '').substring(0, 50) : e.filename || '',
      e.title || '',
      e.artist || '',
      e.artwork_url || '',
      Math.floor((e.time || 0) / 60000)
    ].join('|'));
    const sig = sigParts.join('||') + 
                upcoming.map(u => `up:${u.title}|${u.artist}`).join('||') +
                (live ? `|live:${live.title}|${live.artist}|${live.artwork_url}` : '');

    window._lastSig = window._lastSig || '';
    if (sig === window._lastSig) {
      console.log('Timeline unchanged, skipping render');
      return;
    }
    window._lastSig = sig;

    // Merge with cache, persist (songs only)
    const songsForCache = dedupedPlayed.filter(e => e.type === 'song');
    const merged = mergeWithCache(songsForCache);
    
    // Recombine with DJ events for final display
    const finalEvents = [
      ...merged,
      ...dedupedPlayed.filter(e => e.type === 'dj')
    ].sort((a, b) => new Date(b.time) - new Date(a.time));
    
    saveCache(merged); // Only cache songs

    // ---------- Grouped render in NEW ORDER ----------
    const box = $('timeline');
    box.innerHTML = '';

    function h(tag, cls, html = '') {
      const el = document.createElement(tag);
      if (cls) el.className = cls;
      if (html) el.innerHTML = html;
      return el;
    }

    function section(title) {
      const wrap = h('div', null);
      wrap.appendChild(h('div', 'event-meta', `<strong>${title}</strong>`));
      return wrap;
    }

    function fmtRemaining(ms) {
      const s = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(s / 60), ss = String(s % 60).padStart(2, '0');
      return `${m}:${ss}`;
    }

    function computeRemaining(nowObj) {
      const nowTs = Date.now();
      if (typeof nowObj?.remaining_ms === 'number') return nowObj.remaining_ms;
      if (typeof nowObj?.duration_ms === 'number' && typeof nowObj?.elapsed_ms === 'number')
        return nowObj.duration_ms - nowObj.elapsed_ms;
      if (nowObj?.end_time) return new Date(nowObj.end_time).getTime() - nowTs;
      if (nowObj?.started_at && nowObj?.duration_ms)
        return nowObj.duration_ms - (nowTs - new Date(nowObj.started_at).getTime());
      return null;
    }

    // 1. UPCOMING (First)
    if (upcoming.length) {
      const sec = section('‚è≠Ô∏è UPCOMING');
      for (const ev of upcoming.slice(0, 10)) {
        const div = h('div', 'event upcoming song');
        div.innerHTML = `
          <img alt="Album artwork" loading="lazy" decoding="async" style="background: #0b0d12;">
          <div class="event-details">
            <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip">Upcoming</span></div>
            <div class="event-title">${ev.title || 'Unknown title'}</div>
            <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
          </div>`;
        sec.appendChild(div);
        setCoverOnce(div.querySelector('img'), ev);
      }
      box.appendChild(sec);
    }

    // 2. LIVE NOW (Second)
    if (live) {
      const sec = section('üî¥ LIVE NOW');
      const card = h('div', `event song`);
      card.innerHTML = `
        <img alt="Album artwork" loading="eager" decoding="sync" style="background: #0b0d12;">
        <div class="event-details">
          <div class="event-meta">
            <span>${fmtTime(live.time)}</span>
            <span class="live-chip">LIVE NOW</span>
            <span class="voice-chip" id="remainChip">--:--</span>
          </div>
          <div class="event-title">${live.title || 'Unknown title'}</div>
          <div class="event-sub">${[live.artist, live.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
        </div>`;
      sec.appendChild(card);
      box.appendChild(sec);
      
      // Force set cover immediately
      const img = card.querySelector('img');
      setCoverOnce(img, live);

      let remain = computeRemaining(live);
      const chip = card.querySelector('#remainChip');
      if (remain != null) {
        chip.textContent = `${fmtRemaining(remain)} left`;
        const t = setInterval(() => {
          remain -= 1000;
          if (remain <= 0) { chip.textContent = 'ending‚Ä¶'; clearInterval(t); return; }
          chip.textContent = `${fmtRemaining(remain)} left`;
        }, 1000);
      } else {
        chip.textContent = '‚Äî';
      }
    }

    // 3. JUST PLAYED (Third) - INCLUDING DJ EVENTS
    if (finalEvents.length) {
      const sec = section('üìÄ JUST PLAYED');
      for (const ev of finalEvents) {
        const div = h('div', `event ${ev.type || 'song'}`);
        if (ev.type === 'dj') {
          // Enhanced DJ event display
          div.innerHTML = `
            <div class="event-details" style="width:100%">
              <div class="event-meta">
                <span>${fmtTime(ev.time)}</span>
                <span class="voice-chip">DJ Intro</span>
              </div>
              <div class="event-title">üéôÔ∏è ${ev.text || '(DJ line)'}</div>
              ${ev.audio_url ? `<audio controls preload="none" src="${ev.audio_url}" style="margin-top: 8px; width: 100%;"></audio>` : ''}
            </div>`;
        } else {
          div.innerHTML = `
            <img alt="Album artwork" loading="lazy" decoding="async" style="background: #0b0d12;">
            <div class="event-details">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span></div>
              <div class="event-title">${ev.title || 'Unknown title'}</div>
              <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
            </div>`;
          setCoverOnce(div.querySelector('img'), ev);
        }
        sec.appendChild(div);
      }
      box.appendChild(sec);
    } else {
      // Show empty state if no history
      const sec = section('üìÄ JUST PLAYED');
      const emptyDiv = h('div', 'event-meta');
      emptyDiv.innerHTML = '<em>No tracks played yet. Songs will appear here as they play.</em>';
      sec.appendChild(emptyDiv);
      box.appendChild(sec);
    }

    console.log('Timeline rendered successfully with DJ events');

  } catch (e) {
    console.error('Timeline load error:', e);
    // ... rest of error handling stays the same
  }
}

  $('skipBtn').onclick = async () => { try{ await j('/api/skip',{method:'POST'}); loadTimeline(); } catch(e){} };
  // Enhanced DJ button handler
$('genBtn').onclick = async () => {
  try {
    console.log('Generating DJ line...');
    $('genBtn').disabled = true;
    $('genBtn').textContent = 'Generating...';
    
    // Call the DJ generation endpoint
    const result = await j('/api/dj-now', { method: 'POST' });
    console.log('DJ generation result:', result);
    
    // Force timeline refresh immediately (don't wait)
    window._lastSig = ''; // Force refresh
    setTimeout(() => {
      loadTimeline();
    }, 1000);
    
    // And refresh again after a few seconds to catch the DJ event
    setTimeout(() => {
      window._lastSig = ''; // Force refresh
      loadTimeline();
    }, 5000);
    
  } catch (e) {
    console.error('DJ generation error:', e);
  } finally {
    $('genBtn').disabled = false;
    $('genBtn').textContent = '‚ú® Generate DJ Line';
  }
};

  loadTimeline();
  setInterval(loadTimeline, 10000);
});
</script>
</body>
</html>