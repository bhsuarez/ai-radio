<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI Radio</title>
<style>
  :root {
    --bg: #0f1115; --card:#171a22; --text:#e9ecf1; --muted:#9aa4b2; --accent:#4da3ff;
    --ok:#3ddc97; --warn:#ffb020; --err:#ff5d5d; --radius:14px;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.4 system-ui, sans-serif; display:flex; height:100vh; }
  a { color:var(--accent); text-decoration:none; }

  /* Sidebar */
  .sidebar { width:260px; background:#13161d; border-right:1px solid #1f2531; display:flex; flex-direction:column; padding:16px; gap:12px; }
  .sidebar h1 { font-size:20px; margin:0 0 6px; }
  .btn { appearance:none; border:1px solid #2a2f3a; background:var(--card); color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; text-align:left; }
  .btn:hover { border-color:#3a4150; }
  .btn.accent { background:var(--accent); border-color:var(--accent); color:#041427; }
  .btn.warn { background:var(--warn); border-color:var(--warn); color:#271400; }
  audio { width:100%; }

  /* Main */
  .main { flex:1; display:flex; flex-direction:column; overflow:hidden; }
  header { padding:16px; border-bottom:1px solid #1f2531; display:flex; justify-content:space-between; align-items:center; }
  header .title { font-size:18px; font-weight:600; }
  .timeline { flex:1; overflow-y:auto; padding:16px; display:flex; flex-direction:column; gap:12px; }
  .event { background:var(--card); border-radius:var(--radius); padding:12px; border:1px solid #202634; display:flex; gap:12px; }
  .event.dj { border-left:4px solid var(--accent); }
  .event.song { border-left:4px solid var(--ok); }
  .event.upcoming { opacity:0.85; }
  .event img { width:60px; height:60px; border-radius:8px; object-fit:cover; background:#0b0d12; border:1px solid #1f2531; }
  .event-details { flex:1; }
  .event-meta { font-size:12px; color:var(--muted); margin-bottom:4px; display:flex; gap:8px; flex-wrap:wrap; }
  .voice-chip { padding:2px 6px; border-radius:999px; border:1px solid #1f2531; background:#0f1420; font-size:11px; color:var(--muted); }
  .event-title { font-weight:600; }
  .event-sub { font-size:14px; color:var(--muted); }
  .live-chip { display:inline-block; padding:2px 8px; border-radius:999px; background:#ff4d4d; color:white; font-size:11px; font-weight:bold; margin-right:6px; }
  
  /* Loading spinner */
  .loading-overlay { position:fixed; top:20px; right:20px; background:rgba(15,17,21,0.9); border-radius:8px; padding:12px 16px; display:flex; align-items:center; z-index:1000; box-shadow:0 4px 12px rgba(0,0,0,0.3); }
  .spinner { width:20px; height:20px; border:2px solid var(--card); border-top:2px solid var(--accent); border-radius:50%; animation:spin 1s linear infinite; }
  @keyframes spin { 0% { transform:rotate(0deg); } 100% { transform:rotate(360deg); } }
  .loading-text { color:var(--text); margin-left:12px; font-size:14px; }

  /* Modal styles */
  .modal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:none; align-items:center; justify-content:center; z-index:2000; }
  .modal-content { background:var(--card); border-radius:var(--radius); padding:24px; max-width:600px; width:90%; max-height:80vh; overflow-y:auto; }
  .modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; }
  .modal-title { font-size:18px; font-weight:600; }
  .close-btn { background:none; border:none; color:var(--muted); font-size:24px; cursor:pointer; padding:0; }
  .close-btn:hover { color:var(--text); }
  
  .form-group { margin-bottom:16px; }
  .form-label { display:block; margin-bottom:4px; font-weight:500; color:var(--text); }
  .form-select { width:100%; padding:8px 12px; border:1px solid #2a2f3a; background:var(--bg); color:var(--text); border-radius:6px; }
  .form-select:focus { border-color:var(--accent); outline:none; }
  .form-textarea { width:100%; padding:8px 12px; border:1px solid #2a2f3a; background:var(--bg); color:var(--text); border-radius:6px; resize:vertical; min-height:80px; }
  .form-textarea:focus { border-color:var(--accent); outline:none; }
  .form-input { width:100%; padding:8px 12px; border:1px solid #2a2f3a; background:var(--bg); color:var(--text); border-radius:6px; }
  .form-input:focus { border-color:var(--accent); outline:none; }
  
  .prompt-section { margin-bottom:24px; }
  .prompt-section h3 { margin:0 0 12px; color:var(--accent); font-size:16px; }
  .add-custom { margin-top:12px; padding:8px 16px; background:var(--accent); color:#041427; border:none; border-radius:6px; cursor:pointer; font-weight:500; }
  .add-custom:hover { opacity:0.9; }

  /* Mobile */
  @media (max-width: 768px) {
    body { flex-direction:column; }
    .sidebar { flex-direction:row; flex-wrap:wrap; width:100%; border-right:none; border-bottom:1px solid #1f2531; align-items:center; gap:8px; }
    .sidebar h1 { flex:1 1 100%; margin-bottom:4px; }
    .btn { flex:1; font-size:14px; padding:8px; text-align:center; }
    audio { position:sticky; top:0; z-index:10; background:#13161d; }
    .timeline { padding:8px; }
    .modal-content { width:95%; padding:16px; }
  }
</style>
</head>
<body>
  <aside class="sidebar">
    <h1>üéß AI Radio</h1>
    <audio id="livePlayer" controls preload="none"></audio>
    <button class="btn warn" id="skipBtn">‚è≠Ô∏è Skip Track</button>
    <button class="btn" id="djSettingsBtn">ü§ñ DJ Settings</button>
  </aside>

  <div class="main">
    <header><div class="title">üìú Live Timeline</div></header>
    <div id="timeline" class="timeline"></div>
  </div>

  <!-- DJ Settings Modal -->
  <div id="djSettingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">ü§ñ DJ Settings</h2>
        <button class="close-btn" onclick="closeDJSettings()">&times;</button>
      </div>

      <div class="prompt-section">
        <h3>Intro Prompts (ChatGPT/Ollama)</h3>
        <div class="form-group">
          <label class="form-label">Active Intro Style:</label>
          <select id="activeIntroSelect" class="form-select" onchange="updateActivePrompts()">
            <!-- Options loaded dynamically -->
          </select>
        </div>
      </div>

      <div class="prompt-section">
        <h3>Outro Prompts (ChatGPT/Ollama)</h3>
        <div class="form-group">
          <label class="form-label">Active Outro Style:</label>
          <select id="activeOutroSelect" class="form-select" onchange="updateActivePrompts()">
            <!-- Options loaded dynamically -->
          </select>
        </div>
      </div>

      <div class="prompt-section">
        <h3>Add Custom Prompt</h3>
        <div class="form-group">
          <label class="form-label">Prompt Name:</label>
          <input type="text" id="customPromptName" class="form-input" placeholder="e.g., 'My Custom Style'">
        </div>
        <div class="form-group">
          <label class="form-label">Type:</label>
          <select id="customPromptType" class="form-select">
            <option value="intro">Intro</option>
            <option value="outro">Outro</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Prompt Text:</label>
          <textarea id="customPromptText" class="form-textarea" 
                    placeholder="e.g., 'You are a chill late-night DJ. In 1-2 sentences, introduce {title} by {artist} with a smooth, relaxed vibe.'"></textarea>
        </div>
        <button class="add-custom" onclick="addCustomPrompt()">Add Custom Prompt</button>
      </div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display:none;">
    <div class="spinner"></div>
    <div class="loading-text">Loading timeline...</div>
  </div>

<script>
// --- constants & helpers
const STREAM_URL = "http://icecast.zorro.local:8000/stream.mp3";
const DEFAULT_ART = "/static/station-cover.jpg"; // server-served placeholder

const $ = (id) => document.getElementById(id);
$("livePlayer").src = STREAM_URL; $("livePlayer").load();

function showLoading() { $("loadingOverlay").style.display = "flex"; }
function hideLoading() { $("loadingOverlay").style.display = "none"; }

async function j(url, opts={}) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
  try {
    const r = await fetch(url, { 
      headers: { "Content-Type": "application/json" }, 
      signal: controller.signal,
      ...opts 
    });
    clearTimeout(timeoutId);
    if (!r.ok) throw new Error(await r.text());
    return r.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      console.warn(`Request to ${url} timed out`);
    }
    throw error;
  }
}

const toTime = (ts) => {
  if (!ts) return null;
  const n = Number(ts);
  // support seconds OR ms epoch; support ISO strings
  if (!Number.isNaN(n)) {
    return new Date(n > 1e12 ? n : n * 1000);
  }
  return new Date(ts);
};
const fmtTime = (ts) => { const d = toTime(ts); return d ? d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : ''; };

const ensureArtPath = (url) => {
  if (!url) return DEFAULT_ART;
  // fix old frontends that requested "station-cover.jpg" with no /static
  if (url.endsWith("station-cover.jpg") && !url.includes("/static/")) return DEFAULT_ART;
  return url;
};

function getCover(ev) {
  if (ev.artwork_url && ev.artwork_url !== DEFAULT_ART) return ensureArtPath(ev.artwork_url);
  if (ev.filename) {
    const u = new URL('/api/cover', location.origin); u.searchParams.set('file', ev.filename); return u.toString();
  }
  // Fallback to online cover API using artist/album
  if (ev.artist && ev.album) {
    const u = new URL('/api/cover/online', location.origin);
    u.searchParams.set('artist', ev.artist);
    u.searchParams.set('album', ev.album);
    return u.toString();
  }
  return DEFAULT_ART;
}

function eventKey(e) {
  return (e.filename && e.filename.length > 0)
    ? `f|${e.filename}`
    : `t|${(e.title || '')}|${(e.artist || '')}|${(e.album || '')}`.toLowerCase() || `x|${e.time}`;
}

function setArtworkWithRetry(imgEl, ev, retries = 2) {
  const url = ensureArtPath(getCover(ev));
  const test = new Image();
  test.onload = () => { imgEl.src = url; };
  test.onerror = () => {
    if (retries > 0) setTimeout(() => setArtworkWithRetry(imgEl, ev, retries - 1), 500);
    else imgEl.src = DEFAULT_ART;
  };
  // cache-bust in case the same URL was cached as 404 by the browser
  test.src = url.includes('?') ? `${url}&v=${Date.now()}` : `${url}?v=${Date.now()}`;
}

async function enrichEventsWithArtwork(events) {
  for (const ev of events) {
    if (ev.type === 'song' && !ev.artwork_url && (ev.filename || (ev.title && ev.artist))) {
      try {
        if (ev.filename) {
  ev.artwork_url = `/api/cover?file=${encodeURIComponent(ev.filename)}`;
} else {
  // fallback to station cover
  ev.artwork_url = '/static/station-cover.jpg';
}
      } catch {}
    }
  }
  return events;
}

function sameTrack(a,b){
  if (!a || !b) return false;
  if (a.filename && b.filename && a.filename === b.filename) return true;
  const ta=(a.title||'').trim().toLowerCase(), tb=(b.title||'').trim().toLowerCase();
  const aa=(a.artist||'').trim().toLowerCase(), ab=(b.artist||'').trim().toLowerCase();
  return ta && tb && ta === tb && aa === ab;
}

let lastSig = '';
let lastLiveTrack = null;

async function loadTimeline(){
  try {
    if (window._timelineLoading) return; 
    window._timelineLoading = true;
    showLoading();
    
    // Safety timeout to prevent loading spinner from getting stuck
    const safetyTimeout = setTimeout(() => {
      console.warn('Timeline loading timed out, forcing cleanup');
      window._timelineLoading = false;
      hideLoading();
    }, 15000); // 15 second timeout

    const [nowR, nextR, ttsR, histR] = await Promise.allSettled([
      j('/api/now'), j('/api/next'), j('/api/tts_queue'), j('/api/history')
    ]);
    const now     = nowR.status==='fulfilled' ? nowR.value : {};
    const next    = nextR.status==='fulfilled' ? nextR.value : [];
    const tts     = ttsR.status==='fulfilled' ? ttsR.value : [];
    const history = histR.status==='fulfilled' ? histR.value : [];

    // LIVE NOW - include DJ intros but mark them specially
    const live = (now && (now.title || now.filename)) ? {
      ...now, type: now.title === 'DJ Intro' && now.artist === 'AI DJ' ? 'dj' : 'song', 
      liveNow: true,
      title: now.title || 'Unknown Track', 
      artist: now.artist || 'Unknown Artist',
      text: now.comment || '' // For DJ intros, show the comment as text
    } : null;

    const currentLiveKey = live ? `${live.title}|${live.artist}` : null;
    const liveChanged = lastLiveTrack && lastLiveTrack !== currentLiveKey && currentLiveKey; if (currentLiveKey) lastLiveTrack = currentLiveKey;

    // UPCOMING
    let upcoming = Array.isArray(next) ? next : [];
    upcoming = upcoming
      .filter(s => !sameTrack(s, live))
      .filter(s => s.title !== 'DJ Intro' && s.artist !== 'AI DJ') // Filter out TTS from upcoming too
      .map(s => ({ type:'upcoming', time: Date.now() + Math.random()*1e5, title: s.title || 'Unknown title', artist: s.artist || '', album: s.album || '', filename: s.filename || '', artwork_url: ensureArtPath(s.artwork_url || getCover(s)) }));

    // No client-side lookup; just ensure a usable cover URL or fallback
    upcoming = upcoming.map(t => {
      if (!t.artwork_url) t.artwork_url = ensureArtPath(getCover(t));
      return t;
    });

    // de-dupe upcoming by title|artist and limit to just the next one
    const seenU = new Set();
    upcoming = upcoming.filter(t=>{ const k=`${(t.title||'').toLowerCase()}|${(t.artist||'').toLowerCase()}`; if(seenU.has(k)) return false; seenU.add(k); return true; }).slice(0, 1);

    // HISTORY (already includes DJ entries from backend)
    const events = [...(history||[])];
    // Only add TTS queue items that aren't already in history
    (tts||[]).forEach(t=>{
      const dj={...t,type:'dj',time:t.time||Date.now()};
      const exists = events.find(e=> 
        e.type==='dj' && 
        (e.text===dj.text || e.audio_url===dj.audio_url) && 
        Math.abs((e.time||0)-(dj.time||0))<120000 // 2 minute window
      );
      if(!exists) events.push(dj);
    });
    events.sort((a,b)=> new Date(b.time) - new Date(a.time));

    const songEvents = await enrichEventsWithArtwork(events.filter(e=>e.type==='song'));
    const allEvents = [...songEvents, ...events.filter(e=>e.type==='dj')].sort((a,b)=> new Date(b.time) - new Date(a.time));

    const played = allEvents.filter(e => {
  if (e.type === 'dj') return true;
  if (e.type === 'song') {
    // Hide the currently live track, but keep everything else
    if (live && sameTrack(e, live)) return false;
  }
  return true;
});

    const seenP = new Set();
    const dedupedPlayed = played.filter(tr=>{
      if (tr.type==='dj') return true;
      const k=`${(tr.title||'').toLowerCase()}|${(tr.artist||'').toLowerCase()}`; if(seenP.has(k)) return false; seenP.add(k); return true;
    });

    const sig = dedupedPlayed.map(e=>[e.type||'song', e.filename||'', e.title||'', e.artist||'', Math.floor((e.time||0)/60000)].join('|')).join('||') + upcoming.map(u=>`up:${u.title}|${u.artist}`).join('||') + (live?`|live:${live.title}|${live.artist}`:'');
    if (sig === lastSig) { window._timelineLoading=false; hideLoading(); return; } lastSig = sig;

    // --- render
    const box = $("timeline"); box.innerHTML = '';
    const h = (tag,cls,html='')=>{ const el=document.createElement(tag); if(cls) el.className=cls; if(html) el.innerHTML=html; return el; };
    const section = (title)=>{ const wrap=h('div',null); wrap.appendChild(h('div','event-meta',`<strong>${title}</strong>`)); return wrap; };

    // Upcoming
    if (upcoming.length) {
      const sec = section('‚è≠Ô∏è UPCOMING');
      for (const ev of upcoming) {
        const div=h('div','event upcoming song');
        div.innerHTML = `
          <img alt="Album artwork" loading="lazy" decoding="async">
          <div class="event-details">
            <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip">Upcoming</span></div>
            <div class="event-title">${ev.title || 'Unknown title'}</div>
            <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
          </div>`;
        sec.appendChild(div);
        setArtworkWithRetry(div.querySelector('img'), ev);
      }
      box.appendChild(sec);
    }

    // Live now - distinguish between music and DJ intros
    if (live) {
      if (live.type === 'dj' || live.title === 'DJ Intro') {
        // Show DJ intro as "ON AIR"
        const sec = section('üéôÔ∏è ON AIR');
        const card=h('div','event dj');
        const transcript = live.comment || live.text || 'DJ Commentary';
        const remaining_ms = (live.duration_ms && live.elapsed_ms) ? (live.duration_ms - live.elapsed_ms) : null;
        const progressText = remaining_ms 
          ? `${Math.floor(remaining_ms/1000)}s remaining`
          : '‚Äî';
        card.innerHTML = `
          <div class="event-details" style="width:100%">
            <div class="event-meta"><span>${fmtTime(live.time)}</span><span class="live-chip">LIVE</span><span class="voice-chip">AI DJ</span><span class="voice-chip" id="remainChip">${progressText}</span></div>
            <div class="event-title">üéôÔ∏è ${transcript}</div>
            <div class="event-sub">AI DJ Commentary</div>
          </div>`;
        sec.appendChild(card); box.appendChild(sec);
        
        // Set up real-time progress tracking for DJ intros
        if (live.duration_ms && live.elapsed_ms) {
          window.currentTrackProgress = {
            duration_ms: live.duration_ms,
            elapsed_start: live.elapsed_ms,
            start_time: Date.now()
          };
          startProgressUpdates();
        }
      } else {
        // Show music track as "LIVE NOW"  
        const sec = section('üî¥ LIVE NOW');
        const card=h('div','event song');
        const remaining_ms = (live.duration_ms && live.elapsed_ms) ? (live.duration_ms - live.elapsed_ms) : null;
        const progressText = remaining_ms 
          ? `${Math.floor(remaining_ms/1000)}s remaining`
          : '‚Äî';
        card.innerHTML = `
          <img alt="Album artwork" loading="eager" decoding="sync">
          <div class="event-details">
            <div class="event-meta"><span>${fmtTime(live.time)}</span><span class="live-chip">LIVE NOW</span><span class="voice-chip" id="remainChip">${progressText}</span></div>
            <div class="event-title">${live.title || 'Unknown title'}</div>
            <div class="event-sub">${[live.artist, live.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
          </div>`;
        sec.appendChild(card); box.appendChild(sec);
        setArtworkWithRetry(card.querySelector('img'), live);
        
        // Set up real-time progress tracking for music tracks
        if (live.duration_ms && live.elapsed_ms) {
          window.currentTrackProgress = {
            duration_ms: live.duration_ms,
            elapsed_start: live.elapsed_ms,
            start_time: Date.now()
          };
          startProgressUpdates();
        }
      }
    }

    // Just played
    const sec = section('üìÄ JUST PLAYED');
    if (dedupedPlayed.length) {
      for (const ev of dedupedPlayed) {
        const div=h('div',`event ${ev.type||'song'}`);
        if (ev.type==='dj') {
          div.innerHTML = `
            <div class="event-details" style="width:100%">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span><span class="voice-chip">DJ Intro</span></div>
              <div class="event-title">üéôÔ∏è ${ev.text || '(DJ line)'}</div>
              ${ev.audio_url ? `<audio controls preload="none" src="${ev.audio_url}" style="margin-top:8px; width:100%"></audio>` : ''}
            </div>`;
        } else {
          div.innerHTML = `
            <img alt="Album artwork" loading="lazy" decoding="async">
            <div class="event-details">
              <div class="event-meta"><span>${fmtTime(ev.time)}</span></div>
              <div class="event-title">${ev.title || 'Unknown title'}</div>
              <div class="event-sub">${[ev.artist, ev.album].filter(Boolean).join(' ‚Ä¢ ') || 'Unknown artist'}</div>
            </div>`;
          setArtworkWithRetry(div.querySelector('img'), ev);
        }
        sec.appendChild(div);
      }
    } else {
      const empty=h('div','event-meta'); empty.innerHTML = '<em>No tracks played yet. Songs will appear here as they play.</em>'; sec.appendChild(empty);
    }
    box.appendChild(sec);

  } catch (e) {
    console.error(e);
    $("timeline").innerHTML = '<div class="event-meta" style="text-align:center; padding:20px"><strong>Unable to load timeline</strong><br>Retrying in a few seconds...</div>';
  } finally {
    clearTimeout(safetyTimeout);
    window._timelineLoading = false;
    hideLoading();
    
    // Clear progress tracking if no live track
    if (!live) {
      if (progressInterval) clearInterval(progressInterval);
      window.currentTrackProgress = null;
    }
  }
}

$('skipBtn').onclick = async () => { 
  try{ 
    $('skipBtn').disabled = true; 
    $('skipBtn').textContent = 'Skipping...'; 
    await j('/api/skip',{method:'POST'}); 
    loadTimeline(); 
    $('skipBtn').textContent = 'Skipped!';
    setTimeout(() => { $('skipBtn').disabled = false; $('skipBtn').textContent = '‚è≠Ô∏è Skip Track'; }, 1500);
  } catch(e){ 
    $('skipBtn').disabled = false; 
    $('skipBtn').textContent = '‚è≠Ô∏è Skip Track'; 
  } 
};


// Removed: DJ generation and cleanup button handlers

loadTimeline();
setInterval(loadTimeline, 90000); // Reduced frequency to 90s to prevent loading issues

// Real-time progress updates
let progressInterval = null;
function startProgressUpdates() {
  if (progressInterval) clearInterval(progressInterval);
  
  progressInterval = setInterval(() => {
    const chip = document.getElementById('remainChip');
    if (!chip || !window.currentTrackProgress) return;
    
    const { duration_ms, start_time, elapsed_start } = window.currentTrackProgress;
    if (!duration_ms || !start_time) return;
    
    const elapsed = elapsed_start + (Date.now() - start_time);
    const remaining = Math.max(0, duration_ms - elapsed);
    
    if (remaining <= 0) {
      // Track finished, reload timeline to move to "Just Played"
      chip.textContent = 'Track ending...';
      // Clear the interval to prevent multiple reloads
      if (progressInterval) clearInterval(progressInterval);
      setTimeout(() => loadTimeline(), 2000);
      return;
    }
    
    const remainingSec = Math.floor(remaining / 1000);
    const minutes = Math.floor(remainingSec / 60);
    const seconds = remainingSec % 60;
    
    // Add visual indication when track is ending soon
    if (remainingSec <= 10) {
      chip.style.backgroundColor = 'var(--warn)';
      chip.style.color = '#271400';
      chip.style.fontWeight = 'bold';
    } else if (remainingSec <= 30) {
      chip.style.backgroundColor = 'var(--err)';
      chip.style.color = 'white';
      chip.style.fontWeight = 'bold';
    } else {
      chip.style.backgroundColor = '';
      chip.style.color = '';
      chip.style.fontWeight = '';
    }
    
    if (minutes > 0) {
      chip.textContent = `${minutes}m ${seconds}s remaining`;
    } else {
      chip.textContent = `${seconds}s remaining`;
    }
  }, 1000);
}
</script>
</body>
</html>

<script>
async function loadTtsSettings() {
  try {
    const r = await fetch('/api/settings', {cache:'no-store'});
    const data = await r.json();
    const sel = document.getElementById('ttsProvider');
    if (sel && data && data.tts_provider) sel.value = data.tts_provider;
  } catch (e) { console.error('loadTtsSettings', e); }
}

async function saveTtsProvider() {
  const sel = document.getElementById('ttsProvider');
  const badge = document.getElementById('ttsSaveStatus');
  if (!sel) return;
  const val = sel.value;
  try {
    badge && (badge.textContent = 'Saving‚Ä¶');
    const r = await fetch('/api/settings', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ tts_provider: val })
    });
    const j = await r.json();
    if (j && j.ok) {
      badge && (badge.textContent = 'Saved');
      setTimeout(()=>{ if (badge) badge.textContent=''; }, 1200);
    } else {
      badge && (badge.textContent = 'Error');
      console.error('saveTtsProvider error', j);
    }
  } catch (e) {
    badge && (badge.textContent = 'Error');
    console.error('saveTtsProvider', e);
  }
}

document.addEventListener('change', (ev)=>{
  if (ev.target && ev.target.id === 'ttsProvider') saveTtsProvider();
});

// DJ Settings functionality
let djPromptsData = {};

async function openDJSettings() {
  try {
    djPromptsData = await j('/api/dj-prompts');
    populatePromptSelects();
    $('djSettingsModal').style.display = 'flex';
  } catch (error) {
    console.error('Failed to load DJ prompts:', error);
    alert('Failed to load DJ settings');
  }
}

function closeDJSettings() {
  $('djSettingsModal').style.display = 'none';
}

function populatePromptSelects() {
  const introSelect = $('activeIntroSelect');
  const outroSelect = $('activeOutroSelect');
  
  // Clear existing options
  introSelect.innerHTML = '';
  outroSelect.innerHTML = '';
  
  // Populate intro prompts
  djPromptsData.intro_prompts.forEach(prompt => {
    const option = document.createElement('option');
    option.value = prompt.name;
    option.textContent = prompt.name;
    option.selected = prompt.name === djPromptsData.active_intro_prompt;
    introSelect.appendChild(option);
  });
  
  // Populate outro prompts
  djPromptsData.outro_prompts.forEach(prompt => {
    const option = document.createElement('option');
    option.value = prompt.name;
    option.textContent = prompt.name;
    option.selected = prompt.name === djPromptsData.active_outro_prompt;
    outroSelect.appendChild(option);
  });
}

async function updateActivePrompts() {
  try {
    const activeIntro = $('activeIntroSelect').value;
    const activeOutro = $('activeOutroSelect').value;
    
    await j('/api/dj-prompts/active', {
      method: 'POST',
      body: JSON.stringify({
        active_intro_prompt: activeIntro,
        active_outro_prompt: activeOutro
      })
    });
    
    console.log('Active prompts updated');
  } catch (error) {
    console.error('Failed to update active prompts:', error);
    alert('Failed to update active prompts');
  }
}

async function addCustomPrompt() {
  const name = $('customPromptName').value.trim();
  const type = $('customPromptType').value;
  const prompt = $('customPromptText').value.trim();
  
  if (!name || !prompt) {
    alert('Please fill in both name and prompt text');
    return;
  }
  
  try {
    await j('/api/dj-prompts/custom', {
      method: 'POST',
      body: JSON.stringify({ name, type, prompt })
    });
    
    // Clear form
    $('customPromptName').value = '';
    $('customPromptText').value = '';
    
    // Reload prompts
    djPromptsData = await j('/api/dj-prompts');
    populatePromptSelects();
    
    alert(`Custom ${type} prompt "${name}" added successfully!`);
  } catch (error) {
    console.error('Failed to add custom prompt:', error);
    alert('Failed to add custom prompt: ' + error.message);
  }
}

// Event listeners
$('djSettingsBtn').addEventListener('click', openDJSettings);

// Close modal when clicking outside
$('djSettingsModal').addEventListener('click', (e) => {
  if (e.target === $('djSettingsModal')) {
    closeDJSettings();
  }
});

// Ensure it loads with the rest of the dashboard
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', loadTtsSettings);
} else {
  loadTtsSettings();
}
</script>
