# AI Radio main script (with pre-DJ intros about the NEXT track)

# --- Core / logging -----------------------------------------------------------
set("init.allow_root", true)
set("log.level", 4)

# Telnet control (needed for tts queue pushes)
set("server.telnet", true)
set("server.telnet.bind_addr", "127.0.0.1")
set("server.telnet.port", 1234)

# --- Sources -----------------------------------------------------------------
# Queue for TTS intros (id="tts" exposes telnet commands: tts.push / tts.skip / tts.queue)
tts_q = request.queue(id="tts")

# Load everything from the folder
all_music = playlist(
  mode="random",
  reload=300,
  reload_mode="watch",
  "/opt/ai-radio/library_clean.m3u"
)

# Announce every song to the Flask backend (non-blocking)
def announce_song(m)
  artist = if list.mem("artist", list.map(fst, m)) then m["artist"] else "Unknown Artist" end
  title  = if list.mem("title",  list.map(fst, m)) then m["title"]  else "Unknown" end
  album  = if list.mem("album",  list.map(fst, m)) then m["album"]  else "" end
  file   = if list.mem("filename", list.map(fst, m)) then m["filename"]
           else if list.mem("file", list.map(fst, m)) then m["file"] else "" end end
  ignore(process.run("python3 /opt/ai-radio/post_event.py \"" ^
                     artist ^ "\" \"" ^ title ^ "\" \"" ^ album ^ "\" \"" ^ file ^ "\""))
end
all_music = source.on_metadata(all_music, announce_song)

# Simple log when sine fallback is active
def log_sine(_)
  log("Sine wave fallback active.")
end
sine_src = source.on_metadata(sine(), log_sine)

# --- Optional post-song generator (kept disabled when using pre-DJ) ----------
def after_song(m)
  artist = if list.mem("artist", list.map(fst, m)) then m["artist"] else "Unknown Artist" end
  title  = if list.mem("title",  list.map(fst, m)) then m["title"]  else "Unknown Title" end
  dur_s  = if list.mem("duration", list.map(fst, m)) then float_of_string(m["duration"]) else 0. end
  lead   = 3.0
  wait_s = if dur_s > lead then dur_s - lead else 1.0 end
  log("AUTO-DJ scheduling in " ^ string_of(int_of_float(wait_s)) ^
      "s for next track intro: " ^ title ^ " - " ^ artist)
  ignore(process.run(
    "bash -lc \"(sleep " ^ string_of(int_of_float(wait_s)) ^
    "; /opt/ai-radio/dj_enqueue.sh \\\"" ^ artist ^ "\\\" \\\"" ^ title ^ "\\\" " ^
    ">>/var/tmp/dj_enqueue.log 2>&1) &\""
  ))
end
# all_music = source.on_metadata(all_music, after_song)

# --- PRE-DJ transition: speak about the NEXT track right before it plays -----
def pre_dj(a,b) =
  mb = metadata.export(b)
  next_title  = metadata.title(mb)
  next_artist = metadata.artist(mb)
  next_album  = list.assoc(?default="", "album", mb)
  next_file   = metadata.filename(mb)

  # Synchronously ask Flask to generate /var/tmp/dj_next.mp3 about the NEXT track
  ignore(http.get(
    "http://127.0.0.1:5000/dj-now?"
    ^ "title="  ^ url.encode(next_title)  ^ "&"
    ^ "artist=" ^ url.encode(next_artist) ^ "&"
    ^ "album="  ^ url.encode(next_album)  ^ "&"
    ^ "file="   ^ url.encode(next_file)
  ))

  # Return the single-file source to play BEFORE `b`
  single("/var/tmp/dj_next.mp3")
end

# --- Chain / processing -------------------------------------------------------
# Use our pre-DJ transition between tracks
smooth_music = crossfade(transitions=[pre_dj], all_music)

# 1) song event -> Flask UI
smooth_music = source.on_metadata(smooth_music, announce_song)

# 2) (optional) post-song generator â€” leave commented if you only want pre-song
# smooth_music = source.on_metadata(smooth_music, after_song)

# Main fallback: play TTS inserts when present, else music, else sine
radio = smooth_music

# --- Metadata hygiene ---------------------------------------------------------
def rm_key(m, k)
  list.filter(fun (kv) -> fst(kv) != k, m)
end

def put_default(m, k, v)
  has = list.mem(k, list.map(fst, m))
  cur = if has then list.assoc(k, m) else "" end
  if (not has) or cur == "" then
    m2 = rm_key(m, k)
    list.append(m2, [(k, v)])
  else
    m
  end
end

def update_metadata(m)
  m = put_default(m, "title", "Unknown")
  m = put_default(m, "artist", "Unknown Artist")
  m
end

radio = metadata.map(update_metadata, radio)

# --- Final pipeline -----------------------------------------------------------
music = radio
dj = tts_q
primary = fallback(track_sensitive=true, [dj, music])
radio = fallback(track_sensitive=false, [primary, sine_src])

# --- Output -------------------------------------------------------------------
output.icecast(
  %mp3,
  host="127.0.0.1",
  port=8000,
  user="source",
  password="passw0rd",
  mount="/stream.mp3",
  name="AI Plex DJ",
  url="http://192.168.1.146:8000/",
  genre="Mixed",
  description="24/7 auto-DJ",
  radio
)
